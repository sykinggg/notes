(window.webpackJsonp=window.webpackJsonp||[]).push([[253],{942:function(e,v,_){"use strict";_.r(v);var c=_(1),t=Object(c.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"react-应用的宏观包结构-web-开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-应用的宏观包结构-web-开发"}},[e._v("#")]),e._v(" React 应用的宏观包结构(web 开发)")]),e._v(" "),_("blockquote",[_("p",[e._v("React 工程目录的 packages 下包含 35 个包("),_("a",{attrs:{href:"https://github.com/facebook/react/tree/v17.0.2",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("@17.0.2")]),e._v("版本"),_("OutboundLink")],1),e._v(").\n其中与"),_("code",[e._v("web")]),e._v("开发相关的核心包共有 4 个, 本系列近 20 篇文章, 以这 4 个包为线索进行展开, 深入理解 react 内部作用原理.")])]),e._v(" "),_("h2",{attrs:{id:"基础包结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础包结构"}},[e._v("#")]),e._v(" 基础包结构")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("react")]),e._v(" "),_("blockquote",[_("p",[e._v("react 基础包, 只提供定义 react 组件("),_("code",[e._v("ReactElement")]),e._v(")的必要函数, 一般来说需要和渲染器("),_("code",[e._v("react-dom")]),e._v(","),_("code",[e._v("react-native")]),e._v(")一同使用. 在编写"),_("code",[e._v("react")]),e._v("应用的代码时, 大部分都是调用此包的 api.")])])]),e._v(" "),_("li",[_("p",[e._v("react-dom")]),e._v(" "),_("blockquote",[_("p",[e._v("react 渲染器之一, 是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用), 将"),_("code",[e._v("react-reconciler")]),e._v("中的运行结果输出到 web 界面上. 在编写"),_("code",[e._v("react")]),e._v("应用的代码时,大多数场景下, 能用到此包的就是一个入口函数"),_("code",[e._v("ReactDOM.render(<App/>, document.getElementByID('root'))")]),e._v(", 其余使用的 api, 基本是"),_("code",[e._v("react")]),e._v("包提供的.")])])]),e._v(" "),_("li",[_("p",[e._v("react-reconciler")]),e._v(" "),_("blockquote",[_("p",[e._v("react 得以运行的核心包(综合协调"),_("code",[e._v("react-dom")]),e._v(","),_("code",[e._v("react")]),e._v(","),_("code",[e._v("scheduler")]),e._v("各包之间的调用与配合).\n管理 react 应用状态的输入和结果的输出. 将输入信号最终转换成输出信号传递给渲染器.")])]),e._v(" "),_("ul",[_("li",[e._v("接受输入("),_("code",[e._v("schedulerUpdateOnFiber")]),e._v("), 将"),_("code",[e._v("fiber")]),e._v("树生成逻辑封装到一个回调函数中(涉及"),_("code",[e._v("fiber")]),e._v("树形结构, "),_("code",[e._v("fiber.updateQueue")]),e._v("队列, 调和算法等),")]),e._v(" "),_("li",[e._v("把此回调函数("),_("code",[e._v("performSyncWorkOnRoot")]),e._v("或"),_("code",[e._v("performConcurrentWorkOnRoot")]),e._v(")送入"),_("code",[e._v("scheduler")]),e._v("进行调度")]),e._v(" "),_("li",[_("code",[e._v("scheduler")]),e._v("会控制回调函数执行的时机, 回调函数执行完成后得到全新的 fiber 树")]),e._v(" "),_("li",[e._v("再调用渲染器(如"),_("code",[e._v("react-dom")]),e._v(", "),_("code",[e._v("react-native")]),e._v("等)将 fiber 树形结构最终反映到界面上")])])]),e._v(" "),_("li",[_("p",[e._v("scheduler")]),e._v(" "),_("blockquote",[_("p",[e._v("调度机制的核心实现, 控制由"),_("code",[e._v("react-reconciler")]),e._v("送入的回调函数的执行时机, 在"),_("code",[e._v("concurrent")]),e._v("模式下可以实现任务分片. 在编写"),_("code",[e._v("react")]),e._v("应用的代码时, 同样几乎不会直接用到此包提供的 api.")])]),e._v(" "),_("ul",[_("li",[e._v("核心任务就是执行回调(回调函数由"),_("code",[e._v("react-reconciler")]),e._v("提供)")]),e._v(" "),_("li",[e._v("通过控制回调函数的执行时机, 来达到任务分片的目的, 实现可中断渲染("),_("code",[e._v("concurrent")]),e._v("模式下才有此特性)")])])])]),e._v(" "),_("h2",{attrs:{id:"宏观总览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏观总览"}},[e._v("#")]),e._v(" 宏观总览")]),e._v(" "),_("h3",{attrs:{id:"架构分层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#架构分层"}},[e._v("#")]),e._v(" 架构分层")]),e._v(" "),_("p",[e._v("为了便于理解, 可将 react 应用整体结构分为接口层("),_("code",[e._v("api")]),e._v(")和内核层("),_("code",[e._v("core")]),e._v(")2 个部分")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("接口层(api)\n"),_("code",[e._v("react")]),e._v("包, 平时在开发过程中使用的绝大部分"),_("code",[e._v("api")]),e._v("均来自此包(不是所有). 在"),_("code",[e._v("react")]),e._v("启动之后, 正常可以改变渲染的基本操作有 3 个.")]),e._v(" "),_("ul",[_("li",[e._v("class 组件中使用"),_("code",[e._v("setState()")])]),e._v(" "),_("li",[e._v("function 组件里面使用 hook,并发起"),_("code",[e._v("dispatchAction")]),e._v("去改变 hook 对象")]),e._v(" "),_("li",[e._v("改变 context(其实也需要"),_("code",[e._v("setState")]),e._v("或"),_("code",[e._v("dispatchAction")]),e._v("的辅助才能改变)")])]),e._v(" "),_("p",[e._v("以上"),_("code",[e._v("setState")]),e._v("和"),_("code",[e._v("dispatchAction")]),e._v("都由"),_("code",[e._v("react")]),e._v("包直接暴露. 所以要想 react 工作, 基本上是调用"),_("code",[e._v("react")]),e._v("包的 api 去与其他包进行交互.")])]),e._v(" "),_("li",[_("p",[e._v("内核层(core)\n整个内核部分, 由 3 部分构成:")]),e._v(" "),_("ol",[_("li",[e._v("调度器\n"),_("code",[e._v("scheduler")]),e._v("包, 核心职责只有 1 个, 就是执行回调.\n"),_("ul",[_("li",[e._v("把"),_("code",[e._v("react-reconciler")]),e._v("提供的回调函数, 包装到一个任务对象中.")]),e._v(" "),_("li",[e._v("在内部维护一个任务队列, 优先级高的排在最前面.")]),e._v(" "),_("li",[e._v("循环消费任务队列, 直到队列清空.")])])]),e._v(" "),_("li",[e._v("构造器\n"),_("code",[e._v("react-reconciler")]),e._v("包, 有 3 个核心职责:\n"),_("ol",[_("li",[e._v("装载渲染器, 渲染器必须实现"),_("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("HostConfig")]),e._v("协议"),_("OutboundLink")],1),e._v("(如: "),_("code",[e._v("react-dom")]),e._v("), 保证在需要的时候, 能够正确调用渲染器的 api, 生成实际节点(如: "),_("code",[e._v("dom")]),e._v("节点).")]),e._v(" "),_("li",[e._v("接收"),_("code",[e._v("react-dom")]),e._v("包(初次"),_("code",[e._v("render")]),e._v(")和"),_("code",[e._v("react")]),e._v("包(后续更新"),_("code",[e._v("setState")]),e._v(")发起的更新请求.")]),e._v(" "),_("li",[e._v("将"),_("code",[e._v("fiber")]),e._v("树的构造过程包装在一个回调函数中, 并将此回调函数传入到"),_("code",[e._v("scheduler")]),e._v("包等待调度.")])])]),e._v(" "),_("li",[e._v("渲染器\n"),_("code",[e._v("react-dom")]),e._v("包, 有 2 个核心职责:\n"),_("ol",[_("li",[e._v("引导"),_("code",[e._v("react")]),e._v("应用的启动(通过"),_("code",[e._v("ReactDOM.render")]),e._v(").")]),e._v(" "),_("li",[e._v("实现"),_("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("HostConfig")]),e._v("协议"),_("OutboundLink")],1),e._v("("),_("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/client/ReactDOMHostConfig.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码在 ReactDOMHostConfig.js 中"),_("OutboundLink")],1),e._v("), 能够将"),_("code",[e._v("react-reconciler")]),e._v("包构造出来的"),_("code",[e._v("fiber")]),e._v("树表现出来, 生成 dom 节点(浏览器中), 生成字符串(ssr).")])])])])])]),e._v(" "),_("p",[e._v("注意:")]),e._v(" "),_("ul",[_("li",[e._v("此处分层的标准并非官方说法, 因为官方没有"),_("code",[e._v("架构分层")]),e._v("这样的术语.")]),e._v(" "),_("li",[e._v("本文只是为了深入理解 react, 在官方标准之外, 对其进行分解和剖析, 方便我们理解 react 架构.")])]),e._v(" "),_("h3",{attrs:{id:"内核关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核关系"}},[e._v("#")]),e._v(" 内核关系")]),e._v(" "),_("p",[e._v("现将内核 3 个包的主要职责和调用关系, 绘制到一张概览图上:")]),e._v(" "),_("p",[_("img",{attrs:{src:"/notes/assets/react-illustration-series/core-packages.png",alt:"demo"}})]),e._v(" "),_("p",[e._v("注意:")]),e._v(" "),_("ul",[_("li",[e._v("红色方块代表入口函数, 绿色方块代表出口函数.")]),e._v(" "),_("li",[e._v("package 之间的调用脉络就是通过板块间的入口和出口函数连接起来的.")])])])}),[],!1,null,null,null);v.default=t.exports}}]);