(window.webpackJsonp=window.webpackJsonp||[]).push([[453],{1176:function(t,a,e){"use strict";e.r(a);var s=e(1),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/codebase-overview.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网"),e("OutboundLink")],1)]),t._v(" "),e("h1",{attrs:{id:"源码概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码概览"}},[t._v("#")]),t._v(" 源码概览")]),t._v(" "),e("h2",{attrs:{id:"项目根目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目根目录"}},[t._v("#")]),t._v(" 项目根目录")]),t._v(" "),e("p",[t._v("当克隆 "),e("code",[t._v("React")]),t._v(" 仓库之后，将看到项目根目录的信息")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("packages")]),t._v(" 包含元数据（比如 "),e("code",[t._v("package.json")]),t._v("）和 React 仓库中所有 package 的源码（子目录 "),e("code",[t._v("src")]),t._v("）。"),e("strong",[t._v("如果需要修改源代码, 那么每个包的 src 子目录是最需要花费精力的地方")]),t._v("。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("fixtures")]),t._v(" 包含一些给贡献者准备的小型 React 测试项目。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("build")]),t._v(" 是 React 的输出目录。源码仓库中并没有这个目录，但是它会在克隆 React 并且第一次构建它之后出现。")])])]),t._v(" "),e("h2",{attrs:{id:"共置测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共置测试"}},[t._v("#")]),t._v(" 共置测试")]),t._v(" "),e("p",[t._v("没有单元测试的顶层目录。而是将它们放置在所需测试文件的相同目录下的 "),e("code",[t._v("__tests__")]),t._v(" 的目录之中。")]),t._v(" "),e("p",[t._v("比如，一个用于 "),e("code",[t._v("setInnerHTML.js")]),t._v(" 的测试文件，会存放在 "),e("code",[t._v("__tests__/setInnerHTML-test.js")]),t._v("，就在它同级目录下。")]),t._v(" "),e("h2",{attrs:{id:"warning-和-invariant"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#warning-和-invariant"}},[t._v("#")]),t._v(" warning 和 invariant")]),t._v(" "),e("p",[t._v("React 代码库直接使用 "),e("code",[t._v("console.error")]),t._v(" 来展示 warnings：")]),t._v(" "),e("div",{staticClass:"language-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__DEV__"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Something is wrong.'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("warning 仅在开发环境中启用。在生产环境中，他们会被完全剔除掉。如果需要在生产环境禁止执行某些代码，请使用 "),e("code",[t._v("invariant")]),t._v(" 模块代替 "),e("code",[t._v("warning")]),t._v("：")]),t._v(" "),e("div",{staticClass:"language-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" invariant "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'invariant'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("invariant")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'You shall not pass!'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[e("strong",[t._v("当 invariant 判别条件为 false 时，会将 invariant 的信息作为错误抛出")])]),t._v(" "),e("p",[t._v("“Invariant” 用于声明 “这个条件应总为 true”。可以把它当成一种断言。")]),t._v(" "),e("p",[t._v("保持开发和生产环境的行为相似是十分重要的，因此 "),e("code",[t._v("invariant")]),t._v(" 在开发和生产环境下都会抛出错误。不同点在于在生产环境中这些错误信息会被自动替换成错误代码，这样可以让输出库文件变得更小。")]),t._v(" "),e("h2",{attrs:{id:"开发环境与生产环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发环境与生产环境"}},[t._v("#")]),t._v(" 开发环境与生产环境")]),t._v(" "),e("p",[t._v("可以在代码库中使用 "),e("code",[t._v("__DEV__")]),t._v(" 这个伪全局变量，用于管理开发环境中需运行的代码块")]),t._v(" "),e("p",[t._v("这在编译阶段会被内联，在 CommonJS 构建中，转化成 "),e("code",[t._v("process.env.NODE_ENV !== 'production'")]),t._v(" 这样的判断。")]),t._v(" "),e("p",[t._v("对于独立构建来说，在没有 minify 的构建中，它会变成 "),e("code",[t._v("true")]),t._v("，同时在 minify 的构建中，检测到的 "),e("code",[t._v("if")]),t._v(" 代码块会被完全剔除。")]),t._v(" "),e("div",{staticClass:"language-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__DEV__"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 仅在开发环境下执行的代码")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flow"}},[t._v("#")]),t._v(" Flow")]),t._v(" "),e("p",[t._v("最近将 "),e("code",[t._v("Flow")]),t._v(" 引入源码，用于类型检查。在许可证头部的注释中，标记为 "),e("code",[t._v("@flow")]),t._v(" 注释的文件是已经经过类型检查的。")]),t._v(" "),e("p",[t._v("接受"),e("code",[t._v("添加 Flow 注释到现有代码")]),t._v("。Flow 注释看上去像这样：")]),t._v(" "),e("div",{staticClass:"language-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[t._v("ReactRef"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("detachRefs")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("instance"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ReactInstance"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  element"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ReactElement "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" string "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" number "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("如果可以的话，新代码应尽量使用 Flow 注释。 可以运行 "),e("code",[t._v("yarn flow")]),t._v("，用 Flow 本地检查的代码。")]),t._v(" "),e("h2",{attrs:{id:"multiple-packages"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#multiple-packages"}},[t._v("#")]),t._v(" Multiple Packages")]),t._v(" "),e("p",[t._v("React 采用 "),e("a",{attrs:{href:"https://danluu.com/monorepo/",target:"_blank",rel:"noopener noreferrer"}},[t._v("monorepo"),e("OutboundLink")],1),t._v(" 的管理方式。仓库中包含多个独立的包，以便于更改可以一起联调，并且问题只会出现在同一地方。")]),t._v(" "),e("h2",{attrs:{id:"react-core"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-core"}},[t._v("#")]),t._v(" React Core")]),t._v(" "),e("p",[t._v("React “Core” 中包含所有"),e("code",[t._v("全局 React API")]),t._v("，比如：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("React.createElement()")])]),t._v(" "),e("li",[e("p",[t._v("React.Component")])]),t._v(" "),e("li",[e("p",[t._v("React.Children")])])]),t._v(" "),e("p",[e("strong",[t._v("React 核心只包含定义组件必要的 API")]),t._v("。它不包含协调算法或者其他平台特定的代码。它同时适用于 React DOM 和 React Native 组件。")]),t._v(" "),e("p",[t._v("React 核心代码在源码的 "),e("code",[t._v("packages/react")]),t._v(" 目录中。在 npm 上发布为 "),e("code",[t._v("react")]),t._v(" 包。相应的独立浏览器构建版本称为 "),e("code",[t._v("react.js")]),t._v("，它会导出一个称为 "),e("code",[t._v("React")]),t._v(" 的全局对象。")]),t._v(" "),e("h2",{attrs:{id:"渲染器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染器"}},[t._v("#")]),t._v(" 渲染器")]),t._v(" "),e("p",[t._v("React 最初只是服务于 DOM，但是这之后被改编成也能同时支持原生平台的 React Native。因此，在 React 内部机制中引入了“渲染器”这个概念。")]),t._v(" "),e("p",[e("strong",[t._v("渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用")]),t._v("。")]),t._v(" "),e("p",[t._v("渲染器同样位于 "),e("code",[t._v("packages/")]),t._v(" 目录下：")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("React DOM Renderer")]),t._v(" 将 React 组件渲染成 DOM。它实现了全局 "),e("code",[t._v("ReactDOMAPI")]),t._v("，这在npm上作为 "),e("code",[t._v("react-dom")]),t._v(" 包。这也可以作为单独浏览器版本使用，称为 "),e("code",[t._v("react-dom.js")]),t._v("，导出一个 "),e("code",[t._v("ReactDOM")]),t._v(" 的全局对象.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("React Native Renderer")]),t._v(" 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("React Test Renderer")]),t._v(" 将 React 组件渲染为 JSON 树。这用于 "),e("code",[t._v("Jest")]),t._v(" 的"),e("code",[t._v("快照测试")]),t._v("特性。在 npm 上作为 "),e("code",[t._v("react-test-renderer")]),t._v(" 包发布。")])])]),t._v(" "),e("p",[t._v("另外一个官方支持的渲染器的是 "),e("code",[t._v("react-art")]),t._v("。它曾经是一个独立的 "),e("code",[t._v("GitHub 仓库")]),t._v("，但是现在将此加入了主源代码树。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),t._v(":")]),t._v(" "),e("p",[t._v("严格说来，"),e("code",[t._v("react-native-renderer")]),t._v(" 实现了 React 和 React Native 的连接。真正渲染 Native 视图的平台特定代码及组件都存储在 "),e("code",[t._v("React Native 仓库")]),t._v("中。")])]),t._v(" "),e("h2",{attrs:{id:"reconcilers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reconcilers"}},[t._v("#")]),t._v(" reconcilers")]),t._v(" "),e("p",[t._v("即便 React DOM 和 React Native 渲染器的区别很大，但也需要共享一些逻辑。特别是协调算法需要尽可能相似，这样可以让声明式渲染，自定义组件，state，生命周期方法和 refs 等特性，保持跨平台工作一致。")]),t._v(" "),e("p",[t._v("为了解决这个问题，不同的渲染器彼此共享一些代码。称 React 的这一部分为 “reconciler”。当处理类似于 "),e("code",[t._v("setState()")]),t._v(" 这样的更新时，reconciler 会调用树中组件上的 "),e("code",[t._v("render()")]),t._v("，然后决定是否进行挂载，更新或是卸载操作。")]),t._v(" "),e("p",[t._v("Reconciler 没有单独的包，因为他们暂时没有公共 API。相反，它们被如 React DOM 和 React Native 的渲染器排除在外。")]),t._v(" "),e("h2",{attrs:{id:"fiber-reconciler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-reconciler"}},[t._v("#")]),t._v(" Fiber reconciler")]),t._v(" "),e("p",[t._v("“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。")]),t._v(" "),e("p",[t._v("它的主要目标是：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("能够把可中断的任务切片处理。")])]),t._v(" "),e("li",[e("p",[t._v("能够调整优先级，重置并复用任务。")])]),t._v(" "),e("li",[e("p",[t._v("能够在父元素与子元素之间交错处理，以支持 React 中的布局。")])]),t._v(" "),e("li",[e("p",[t._v("能够在 render() 中返回多个元素。")])]),t._v(" "),e("li",[e("p",[t._v("更好地支持错误边界。")])])]),t._v(" "),e("p",[t._v("源代码在 "),e("code",[t._v("packages/react-reconciler")]),t._v(" 目录下")]),t._v(" "),e("h2",{attrs:{id:"事件系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[t._v("#")]),t._v(" 事件系统")]),t._v(" "),e("p",[t._v("React 在原生事件基础上进行了封装，以抹平浏览器间差异。其源码在 "),e("code",[t._v("packages/react-dom/src/events")]),t._v(" 目录下")])])}),[],!1,null,null,null);a.default=r.exports}}]);