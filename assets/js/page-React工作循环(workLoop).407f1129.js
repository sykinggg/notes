(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{923:function(e,v,_){"use strict";_.r(v);var o=_(1),r=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"react-工作循环-workloop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-工作循环-workloop"}},[e._v("#")]),e._v(" React 工作循环 (workLoop)")]),e._v(" "),_("p",[e._v("在前文("),_("RouterLink",{attrs:{to:"/react-illustration-series/main/macro-structure.html"}},[e._v("React 应用的宏观包结构")]),e._v(")中, 介绍了"),_("code",[e._v("react")]),e._v("核心包之间的依赖和调用关系, 并绘制出了概览图. 在概览图中, 可以看到有两个大的循环, 它们分别位于"),_("code",[e._v("scheduler")]),e._v("和"),_("code",[e._v("react-reconciler")]),e._v("包中:")],1),e._v(" "),_("p",[_("img",{attrs:{src:"/notes/assets/react-illustration-series/workloop.png",alt:""}})]),e._v(" "),_("p",[e._v("本文将这两个循环分别表述为"),_("code",[e._v("任务调度循环")]),e._v("和"),_("code",[e._v("fiber构造循环")]),e._v(". 接下来从宏观角度阐述这两大循环的作用, 以及它们之间的区别和联系. 更深入的源码分析分别在"),_("code",[e._v("scheduler 调度机制")]),e._v("和"),_("code",[e._v("fiber 树构造")]),e._v("章节中详细解读.")]),e._v(" "),_("ol",[_("li",[_("code",[e._v("任务调度循环")])])]),e._v(" "),_("p",[e._v("源码位于"),_("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/Scheduler.js",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("Scheduler.js")]),_("OutboundLink")],1),e._v(", 它是"),_("code",[e._v("react")]),e._v("应用得以运行的保证, 它需要循环调用, 控制所有任务("),_("code",[e._v("task")]),e._v(")的调度.")]),e._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("code",[e._v("fiber构造循环")])])]),e._v(" "),_("p",[e._v("源码位于"),_("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("ReactFiberWorkLoop.js")]),_("OutboundLink")],1),e._v(", 控制 fiber 树的构造, 整个过程是一个"),_("RouterLink",{attrs:{to:"/react-illustration-series/algorithm/dfs.html"}},[e._v("深度优先遍历")]),e._v(".")],1),e._v(" "),_("p",[e._v("这两个循环对应的 js 源码不同于其他闭包(运行时就是闭包), 其中定义的全局变量, 不仅是该作用域的私有变量, 更用于"),_("code",[e._v("控制react应用的执行过程")]),e._v(".")]),e._v(" "),_("h2",{attrs:{id:"区别与联系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别与联系"}},[e._v("#")]),e._v(" 区别与联系")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("区别")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("任务调度循环")]),e._v("是以"),_("code",[e._v("二叉堆")]),e._v("为数据结构(详见"),_("RouterLink",{attrs:{to:"/react-illustration-series/algorithm/heapsort.html"}},[e._v("react 算法之堆排序")]),e._v("), 循环执行"),_("code",[e._v("堆")]),e._v("的顶点, 直到"),_("code",[e._v("堆")]),e._v("被清空.")],1),e._v(" "),_("li",[_("code",[e._v("任务调度循环")]),e._v("的逻辑偏向宏观, 它调度的是每一个任务("),_("code",[e._v("task")]),e._v("), 而不关心这个任务具体是干什么的(甚至可以将"),_("code",[e._v("Scheduler")]),e._v("包脱离"),_("code",[e._v("react")]),e._v("使用), 具体任务其实就是执行回调函数"),_("code",[e._v("performSyncWorkOnRoot")]),e._v("或"),_("code",[e._v("performConcurrentWorkOnRoot")]),e._v(".")]),e._v(" "),_("li",[_("code",[e._v("fiber构造循环")]),e._v("是以"),_("code",[e._v("树")]),e._v("为数据结构, 从上至下执行深度优先遍历(详见"),_("RouterLink",{attrs:{to:"/react-illustration-series/algorithm/dfs.html"}},[e._v("react 算法之深度优先遍历")]),e._v(").")],1),e._v(" "),_("li",[_("code",[e._v("fiber构造循环")]),e._v("的逻辑偏向具体实现, 它只是任务("),_("code",[e._v("task")]),e._v(")的一部分(如"),_("code",[e._v("performSyncWorkOnRoot")]),e._v("包括: "),_("code",[e._v("fiber")]),e._v("树的构造, "),_("code",[e._v("DOM")]),e._v("渲染, 调度检测), 只负责"),_("code",[e._v("fiber")]),e._v("树的构造.")])])]),e._v(" "),_("li",[_("p",[e._v("联系")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("fiber构造循环")]),e._v("是"),_("code",[e._v("任务调度循环")]),e._v("中的任务("),_("code",[e._v("task")]),e._v(")的一部分. 它们是从属关系, 每个任务都会重新构造一个"),_("code",[e._v("fiber")]),e._v("树.")])])])]),e._v(" "),_("h2",{attrs:{id:"主干逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主干逻辑"}},[e._v("#")]),e._v(" 主干逻辑")]),e._v(" "),_("p",[e._v("通过上文的描述, 两大循环的分工可以总结为: 大循环(任务调度循环)负责调度"),_("code",[e._v("task")]),e._v(", 小循环(fiber 构造循环)负责实现"),_("code",[e._v("task")]),e._v(" .")]),e._v(" "),_("p",[e._v("react 运行的主干逻辑, 即将"),_("code",[e._v("输入转换为输出")]),e._v("的核心步骤, 实际上就是围绕这两大工作循环进行展开.")]),e._v(" "),_("p",[e._v("结合上文的宏观概览图(展示核心包之间的调用关系), 可以将 react 运行的主干逻辑进行概括:")]),e._v(" "),_("ol",[_("li",[e._v("输入: 将每一次更新(如: 新增, 删除, 修改节点之后)视为一次"),_("code",[e._v("更新需求")]),e._v("(目的是要更新"),_("code",[e._v("DOM")]),e._v("节点).")]),e._v(" "),_("li",[e._v("注册调度任务: "),_("code",[e._v("react-reconciler")]),e._v("收到"),_("code",[e._v("更新需求")]),e._v("之后, 并不会立即构造"),_("code",[e._v("fiber树")]),e._v(", 而是去调度中心"),_("code",[e._v("scheduler")]),e._v("注册一个新任务"),_("code",[e._v("task")]),e._v(", 即把"),_("code",[e._v("更新需求")]),e._v("转换成一个"),_("code",[e._v("task")]),e._v(".")]),e._v(" "),_("li",[e._v("执行调度任务(输出): 调度中心"),_("code",[e._v("scheduler")]),e._v("通过"),_("code",[e._v("任务调度循环")]),e._v("来执行"),_("code",[e._v("task")]),e._v("("),_("code",[e._v("task")]),e._v("的执行过程又回到了"),_("code",[e._v("react-reconciler")]),e._v("包中).\n"),_("ul",[_("li",[_("code",[e._v("fiber构造循环")]),e._v("是"),_("code",[e._v("task")]),e._v("的实现环节之一, 循环完成之后会构造出最新的 fiber 树.")]),e._v(" "),_("li",[_("code",[e._v("commitRoot")]),e._v("是"),_("code",[e._v("task")]),e._v("的实现环节之二, 把最新的 fiber 树最终渲染到页面上, "),_("code",[e._v("task")]),e._v("完成.")])])])]),e._v(" "),_("p",[e._v("主干逻辑就是"),_("code",[e._v("输入到输出")]),e._v("这一条链路, 为了更好的性能(如"),_("code",[e._v("批量更新")]),e._v(", "),_("code",[e._v("可中断渲染")]),e._v("等功能), "),_("code",[e._v("react")]),e._v("在输入到输出的链路上做了很多优化策略, 比如本文讲述的"),_("code",[e._v("任务调度循环")]),e._v("和"),_("code",[e._v("fiber构造循环")]),e._v("相互配合就可以实现"),_("code",[e._v("可中断渲染")]),e._v(".")])])}),[],!1,null,null,null);v.default=r.exports}}]);