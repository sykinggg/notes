<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入TypeScript | 前端 学习</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <link rel="manifest" href="/notes/manifest.webmanifest" crossorigin="use-credentials">
    <meta name="description" content="君子藏器于身 待时而动 天下有道则见 无道则隐">
    <meta property="og:url" content="/notes/ts/project/inDepthTs.html">
    <meta property="og:site_name" content="前端 学习">
    <meta property="og:title" content="深入TypeScript">
    <meta property="og:description" content="深入TypeScript 第一部分 前置内容 keyof 索引查询; 对应任何类型T,keyof T的结果为该类型上所有共有属性key的联合： T[K] 索引访问; T[keyof T]的方式，可以获取到T所有key的类型组成的联合类型；T[keyof K]的方式，获取到的是T中的key且同时存在于K时的类型组成的联合类型；注意：如果[]中的key有不存在T">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en-US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="前端 学习">
    <meta property="article:author" content="sy">
    <meta name="theme-color" content="#46bd87">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    
    <link rel="preload" href="/notes/assets/css/0.styles.33b160dd.css" as="style"><link rel="preload" href="/notes/assets/js/app.e8b8d673.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Layout.797b930b.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.fd95594f.js" as="script"><link rel="preload" href="/notes/assets/js/page-深入TypeScript.7d08d3f1.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.5018eb2c.js" as="script"><link rel="prefetch" href="/notes/assets/js/598.f460589e.js"><link rel="prefetch" href="/notes/assets/js/599.fb23b34f.js"><link rel="prefetch" href="/notes/assets/js/600.6061f26e.js"><link rel="prefetch" href="/notes/assets/js/layout-Blog.b230af33.js"><link rel="prefetch" href="/notes/assets/js/layout-Layout.cb0003cf.js"><link rel="prefetch" href="/notes/assets/js/layout-NotFound.6331fdd1.js"><link rel="prefetch" href="/notes/assets/js/layout-Slide.da176676.js"><link rel="prefetch" href="/notes/assets/js/mermaid.1acaf644.js"><link rel="prefetch" href="/notes/assets/js/page-$mount.657d4d8c.js"><link rel="prefetch" href="/notes/assets/js/page--0036d571.89459f81.js"><link rel="prefetch" href="/notes/assets/js/page--022ad8a1.931f8d2d.js"><link rel="prefetch" href="/notes/assets/js/page--049c9a9f.5680254d.js"><link rel="prefetch" href="/notes/assets/js/page--050f4996.6c2fa45a.js"><link rel="prefetch" href="/notes/assets/js/page--05ca34d9.18ca605d.js"><link rel="prefetch" href="/notes/assets/js/page--06138101.45a79482.js"><link rel="prefetch" href="/notes/assets/js/page--078553ea.034dd6cf.js"><link rel="prefetch" href="/notes/assets/js/page--07c5ad21.b336b5de.js"><link rel="prefetch" href="/notes/assets/js/page--07f0b7af.fb81fb72.js"><link rel="prefetch" href="/notes/assets/js/page--08402fbe.dcce8b04.js"><link rel="prefetch" href="/notes/assets/js/page--0a137961.1c305548.js"><link rel="prefetch" href="/notes/assets/js/page--0b6292d3.a427742b.js"><link rel="prefetch" href="/notes/assets/js/page--0b81571e.6b88b1e8.js"><link rel="prefetch" href="/notes/assets/js/page--0c7d4a27.fb388397.js"><link rel="prefetch" href="/notes/assets/js/page--0d936993.5ae2ae06.js"><link rel="prefetch" href="/notes/assets/js/page--0e573275.8875d7b4.js"><link rel="prefetch" href="/notes/assets/js/page--0f2ef575.365d3043.js"><link rel="prefetch" href="/notes/assets/js/page--0fb13921.8da2dfa8.js"><link rel="prefetch" href="/notes/assets/js/page--0fe0372e.4ff6676a.js"><link rel="prefetch" href="/notes/assets/js/page--10902ffe.6f12cc34.js"><link rel="prefetch" href="/notes/assets/js/page--12bc566b.0591b2fa.js"><link rel="prefetch" href="/notes/assets/js/page--135834a1.d8cd7c48.js"><link rel="prefetch" href="/notes/assets/js/page--15961e72.5bff837d.js"><link rel="prefetch" href="/notes/assets/js/page--17036b33.1728d913.js"><link rel="prefetch" href="/notes/assets/js/page--172068b9.cd2b256c.js"><link rel="prefetch" href="/notes/assets/js/page--18126b85.df3e8fcc.js"><link rel="prefetch" href="/notes/assets/js/page--19a1b422.41c10723.js"><link rel="prefetch" href="/notes/assets/js/page--1a00028a.ebdc779a.js"><link rel="prefetch" href="/notes/assets/js/page--1c6aa5c2.29ed796d.js"><link rel="prefetch" href="/notes/assets/js/page--1fece121.4ee03aa1.js"><link rel="prefetch" href="/notes/assets/js/page--201cfbe1.277f6295.js"><link rel="prefetch" href="/notes/assets/js/page--2095282b.ba786287.js"><link rel="prefetch" href="/notes/assets/js/page--21792c01.cb8067f8.js"><link rel="prefetch" href="/notes/assets/js/page--226f1079.1b00e89e.js"><link rel="prefetch" href="/notes/assets/js/page--2518076e.0697a6aa.js"><link rel="prefetch" href="/notes/assets/js/page--25cb6e5f.fbc173bb.js"><link rel="prefetch" href="/notes/assets/js/page--2616bc7e.95c65647.js"><link rel="prefetch" href="/notes/assets/js/page--27a556ad.357e5f27.js"><link rel="prefetch" href="/notes/assets/js/page--27c21126.8bd40bee.js"><link rel="prefetch" href="/notes/assets/js/page--28435cbb.67e4b063.js"><link rel="prefetch" href="/notes/assets/js/page--28c148fe.a3899ea7.js"><link rel="prefetch" href="/notes/assets/js/page--2ae50662.985f4dea.js"><link rel="prefetch" href="/notes/assets/js/page--2c665981.96e1ead4.js"><link rel="prefetch" href="/notes/assets/js/page--2d021821.6c2a0129.js"><link rel="prefetch" href="/notes/assets/js/page--31799879.bda7eeba.js"><link rel="prefetch" href="/notes/assets/js/page--33b11326.64605e09.js"><link rel="prefetch" href="/notes/assets/js/page--3477437b.8d314c33.js"><link rel="prefetch" href="/notes/assets/js/page--34ad062f.eedc4a01.js"><link rel="prefetch" href="/notes/assets/js/page--357aec57.92c9bdcd.js"><link rel="prefetch" href="/notes/assets/js/page--35f61a61.72932195.js"><link rel="prefetch" href="/notes/assets/js/page--36897e27.04e02bab.js"><link rel="prefetch" href="/notes/assets/js/page--36b30161.9e05e7e6.js"><link rel="prefetch" href="/notes/assets/js/page--377508c1.7a7d8ee1.js"><link rel="prefetch" href="/notes/assets/js/page--3779bcfe.a11aa8a0.js"><link rel="prefetch" href="/notes/assets/js/page--389d5da5.48623a3d.js"><link rel="prefetch" href="/notes/assets/js/page--38ef908f.f9ad3a7b.js"><link rel="prefetch" href="/notes/assets/js/page--39c1a916.bf9e911c.js"><link rel="prefetch" href="/notes/assets/js/page--39e34c63.f2e06dcb.js"><link rel="prefetch" href="/notes/assets/js/page--3bbd34b1.86804dc0.js"><link rel="prefetch" href="/notes/assets/js/page--3d00ca45.5c205390.js"><link rel="prefetch" href="/notes/assets/js/page--3d121781.e6275742.js"><link rel="prefetch" href="/notes/assets/js/page--3d5ab373.067dcd1a.js"><link rel="prefetch" href="/notes/assets/js/page--41d1702a.0512019f.js"><link rel="prefetch" href="/notes/assets/js/page--427db7c1.67caa326.js"><link rel="prefetch" href="/notes/assets/js/page--4365fcbe.8256bb9e.js"><link rel="prefetch" href="/notes/assets/js/page--466a516d.faef2349.js"><link rel="prefetch" href="/notes/assets/js/page--46f53541.07e69f6b.js"><link rel="prefetch" href="/notes/assets/js/page--4776c269.59e0bccd.js"><link rel="prefetch" href="/notes/assets/js/page--4803a967.ac0cd127.js"><link rel="prefetch" href="/notes/assets/js/page--48c4e433.aa561e9c.js"><link rel="prefetch" href="/notes/assets/js/page--48f9c9d9.184df274.js"><link rel="prefetch" href="/notes/assets/js/page--4a252f57.bfae4b90.js"><link rel="prefetch" href="/notes/assets/js/page--4b35cd6a.815cabfc.js"><link rel="prefetch" href="/notes/assets/js/page--4bd2c839.ce5d2364.js"><link rel="prefetch" href="/notes/assets/js/page--4be1980d.2aa9a6e5.js"><link rel="prefetch" href="/notes/assets/js/page--4c3dfc92.5398aa64.js"><link rel="prefetch" href="/notes/assets/js/page--4c9b9bf3.23ec56a1.js"><link rel="prefetch" href="/notes/assets/js/page--4caf2956.0cb678d9.js"><link rel="prefetch" href="/notes/assets/js/page--4df59ba1.7da8848b.js"><link rel="prefetch" href="/notes/assets/js/page--4dfb2a67.85e729c7.js"><link rel="prefetch" href="/notes/assets/js/page--4e2425dd.530ff427.js"><link rel="prefetch" href="/notes/assets/js/page--4eb2620a.0ab3bf7d.js"><link rel="prefetch" href="/notes/assets/js/page--4fd512b5.d04f2560.js"><link rel="prefetch" href="/notes/assets/js/page--4ff1cd2e.485a1d23.js"><link rel="prefetch" href="/notes/assets/js/page--505dfb41.f1f12989.js"><link rel="prefetch" href="/notes/assets/js/page--5293e923.7d7bb4c5.js"><link rel="prefetch" href="/notes/assets/js/page--5381ba01.a19f6d31.js"><link rel="prefetch" href="/notes/assets/js/page--550b58e9.36d41d59.js"><link rel="prefetch" href="/notes/assets/js/page--564b24b3.61702c03.js"><link rel="prefetch" href="/notes/assets/js/page--598867f3.c2ee7bca.js"><link rel="prefetch" href="/notes/assets/js/page--5be0cf2e.c6563f71.js"><link rel="prefetch" href="/notes/assets/js/page--5c1b876b.baacb2d8.js"><link rel="prefetch" href="/notes/assets/js/page--60c3812d.2781a78e.js"><link rel="prefetch" href="/notes/assets/js/page--6213086b.02e6e5c5.js"><link rel="prefetch" href="/notes/assets/js/page--624c4841.aef58546.js"><link rel="prefetch" href="/notes/assets/js/page--6389398f.08880043.js"><link rel="prefetch" href="/notes/assets/js/page--6497f0a1.f07215b3.js"><link rel="prefetch" href="/notes/assets/js/page--649d273e.1b9dea3d.js"><link rel="prefetch" href="/notes/assets/js/page--663eaefe.837e8ddf.js"><link rel="prefetch" href="/notes/assets/js/page--66f10201.a1a7d046.js"><link rel="prefetch" href="/notes/assets/js/page--6877a3e2.a3a41342.js"><link rel="prefetch" href="/notes/assets/js/page--6afe7ce1.ed6233f1.js"><link rel="prefetch" href="/notes/assets/js/page--6cbf38e1.4828ca72.js"><link rel="prefetch" href="/notes/assets/js/page--6ce92f3e.44efe439.js"><link rel="prefetch" href="/notes/assets/js/page--6e597d21.a2747ea4.js"><link rel="prefetch" href="/notes/assets/js/page--6e740896.23e81204.js"><link rel="prefetch" href="/notes/assets/js/page--6f049967.bad4d54a.js"><link rel="prefetch" href="/notes/assets/js/page--6ff33237.5953c3fe.js"><link rel="prefetch" href="/notes/assets/js/page--70f1ad1b.e08da168.js"><link rel="prefetch" href="/notes/assets/js/page--7458eaaa.e6562e2b.js"><link rel="prefetch" href="/notes/assets/js/page--746db89a.2b8b0c6f.js"><link rel="prefetch" href="/notes/assets/js/page--762ae66f.e5d2408c.js"><link rel="prefetch" href="/notes/assets/js/page--78218936.704caeaf.js"><link rel="prefetch" href="/notes/assets/js/page--7a6b8eb1.1d55dea6.js"><link rel="prefetch" href="/notes/assets/js/page--7b0b14b7.dccec62e.js"><link rel="prefetch" href="/notes/assets/js/page--7b24903e.5c69642f.js"><link rel="prefetch" href="/notes/assets/js/page--7c0f4619.5dcc0529.js"><link rel="prefetch" href="/notes/assets/js/page--7c62eb01.ab10ad09.js"><link rel="prefetch" href="/notes/assets/js/page--7c8b8781.f7d52591.js"><link rel="prefetch" href="/notes/assets/js/page--7d3b14f1.1dd87265.js"><link rel="prefetch" href="/notes/assets/js/page--7e94c3bb.d8d033fe.js"><link rel="prefetch" href="/notes/assets/js/page--7fc7e4a1.85ff3908.js"><link rel="prefetch" href="/notes/assets/js/page--82271b92.70ced054.js"><link rel="prefetch" href="/notes/assets/js/page--828e159e.51db0908.js"><link rel="prefetch" href="/notes/assets/js/page--8cd36aaa.0df786c0.js"><link rel="prefetch" href="/notes/assets/js/page--8e28d8be.8431c4a2.js"><link rel="prefetch" href="/notes/assets/js/page--9009daaa.75fef5ab.js"><link rel="prefetch" href="/notes/assets/js/page--9230e83a.83a6b857.js"><link rel="prefetch" href="/notes/assets/js/page--9fdba57e.799fe585.js"><link rel="prefetch" href="/notes/assets/js/page--a051453e.785431b2.js"><link rel="prefetch" href="/notes/assets/js/page--a1c4239e.2cd11b39.js"><link rel="prefetch" href="/notes/assets/js/page--a8a8c1be.a5750b48.js"><link rel="prefetch" href="/notes/assets/js/page--aabdd1a6.b75a951a.js"><link rel="prefetch" href="/notes/assets/js/page--b0ec1952.0df82150.js"><link rel="prefetch" href="/notes/assets/js/page--b5901aa6.a2b583d6.js"><link rel="prefetch" href="/notes/assets/js/page--c185ca2a.4aefcb13.js"><link rel="prefetch" href="/notes/assets/js/page--c4cd30aa.2ac4e19b.js"><link rel="prefetch" href="/notes/assets/js/page--cba59586.5743b116.js"><link rel="prefetch" href="/notes/assets/js/page--cc19dc5e.30448e51.js"><link rel="prefetch" href="/notes/assets/js/page--cf39bd12.dbb9d85c.js"><link rel="prefetch" href="/notes/assets/js/page--d0d30f3e.81e38c82.js"><link rel="prefetch" href="/notes/assets/js/page--d206ab7e.06616b75.js"><link rel="prefetch" href="/notes/assets/js/page--d2ed8dae.effdc7c1.js"><link rel="prefetch" href="/notes/assets/js/page--d676831e.b99f20db.js"><link rel="prefetch" href="/notes/assets/js/page--d6d819fe.07462fbb.js"><link rel="prefetch" href="/notes/assets/js/page--d994fd7e.a6adff43.js"><link rel="prefetch" href="/notes/assets/js/page--dd5a1a16.fc06467a.js"><link rel="prefetch" href="/notes/assets/js/page--df9ce13a.d24f3f28.js"><link rel="prefetch" href="/notes/assets/js/page--e0b57efe.5bfeda2b.js"><link rel="prefetch" href="/notes/assets/js/page--eb673c12.08a8b172.js"><link rel="prefetch" href="/notes/assets/js/page--ebf2773e.98a50551.js"><link rel="prefetch" href="/notes/assets/js/page--ef64acb6.e34bea68.js"><link rel="prefetch" href="/notes/assets/js/page--f77f473e.711e878d.js"><link rel="prefetch" href="/notes/assets/js/page--fb1d49b6.bc055bed.js"><link rel="prefetch" href="/notes/assets/js/page-1、说说你对SPA单页面的理解，它的优缺点分别是什么？.a5776851.js"><link rel="prefetch" href="/notes/assets/js/page-49个CSS知识点.9782cb4d.js"><link rel="prefetch" href="/notes/assets/js/page-@charset.577d7a05.js"><link rel="prefetch" href="/notes/assets/js/page-@types.12e38f09.js"><link rel="prefetch" href="/notes/assets/js/page-@umijsplugin-dva.c71a8613.js"><link rel="prefetch" href="/notes/assets/js/page-@umijsplugin-qiankun.52935bce.js"><link rel="prefetch" href="/notes/assets/js/page-AMD模块.71ab9929.js"><link rel="prefetch" href="/notes/assets/js/page-API.3544dc34.js"><link rel="prefetch" href="/notes/assets/js/page-Arrayprototypeflat().f8f40de1.js"><link rel="prefetch" href="/notes/assets/js/page-Barrel.0542e85c.js"><link rel="prefetch" href="/notes/assets/js/page-Bind是有害的.3f1dd724.js"><link rel="prefetch" href="/notes/assets/js/page-CSSGrid网格布局教程.09ebe3b9.js"><link rel="prefetch" href="/notes/assets/js/page-CSS选择符.82bd60e4.js"><link rel="prefetch" href="/notes/assets/js/page-Canvas和SVG区别.ae73fca5.js"><link rel="prefetch" href="/notes/assets/js/page-CommonJS.196d98c0.js"><link rel="prefetch" href="/notes/assets/js/page-Configuration.2952591a.js"><link rel="prefetch" href="/notes/assets/js/page-Consumer向上找不到Provider的时候怎么办.09eb5f1b.js"><link rel="prefetch" href="/notes/assets/js/page-ContentTypes.750ff067.js"><link rel="prefetch" href="/notes/assets/js/page-Css单位.15c9eb21.js"><link rel="prefetch" href="/notes/assets/js/page-Decorators.1e601960.js"><link rel="prefetch" href="/notes/assets/js/page-Diff算法.236fa231.js"><link rel="prefetch" href="/notes/assets/js/page-ES10新特性（2019）.bf0cdc87.js"><link rel="prefetch" href="/notes/assets/js/page-ES6新特性（2015）.1975d057.js"><link rel="prefetch" href="/notes/assets/js/page-ES7新特性（2016）.2daf5a4e.js"><link rel="prefetch" href="/notes/assets/js/page-ES8新特性（2017）.bf45dda5.js"><link rel="prefetch" href="/notes/assets/js/page-ES9新特性（2018）.197b145a.js"><link rel="prefetch" href="/notes/assets/js/page-FetchAPI教程.69f3a2c6.js"><link rel="prefetch" href="/notes/assets/js/page-FileReader.4cfa7fec.js"><link rel="prefetch" href="/notes/assets/js/page-Flex布局教程：实例篇.d3393d8c.js"><link rel="prefetch" href="/notes/assets/js/page-Flex布局教程：语法篇.3be19f6b.js"><link rel="prefetch" href="/notes/assets/js/page-Flyweight模式.a1b15e40.js"><link rel="prefetch" href="/notes/assets/js/page-Fragment.c1731548.js"><link rel="prefetch" href="/notes/assets/js/page-Freshness.383b4cdb.js"><link rel="prefetch" href="/notes/assets/js/page-Generator.6ce78213.js"><link rel="prefetch" href="/notes/assets/js/page-Git面试知识点.d4a830ef.js"><link rel="prefetch" href="/notes/assets/js/page-HTML5datalist标签.e3c3117d.js"><link rel="prefetch" href="/notes/assets/js/page-HTML常用特殊字符.7657b05c.js"><link rel="prefetch" href="/notes/assets/js/page-Home.59e67adb.js"><link rel="prefetch" href="/notes/assets/js/page-Hybrid.0c26b596.js"><link rel="prefetch" href="/notes/assets/js/page-ID选择器.9c962dbc.js"><link rel="prefetch" href="/notes/assets/js/page-ImmutableData.1345a7ff.js"><link rel="prefetch" href="/notes/assets/js/page-Introduction.ae30a5eb.js"><link rel="prefetch" href="/notes/assets/js/page-JSX和React.4ce32c5a.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript实现双向链表.6a64c8e4.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript执行机制.99640d44.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript设计模式的分类.16c36855.js"><link rel="prefetch" href="/notes/assets/js/page-MVC模式.3e0a7d93.js"><link rel="prefetch" href="/notes/assets/js/page-MVP模式.968247da.js"><link rel="prefetch" href="/notes/assets/js/page-MVVM.c03efed1.js"><link rel="prefetch" href="/notes/assets/js/page-Map.2172c5a4.js"><link rel="prefetch" href="/notes/assets/js/page-Mixin模式.17436ad3.js"><link rel="prefetch" href="/notes/assets/js/page-Modulardesign(模块化设计).38db01f2.js"><link rel="prefetch" href="/notes/assets/js/page-Never.f393d32f.js"><link rel="prefetch" href="/notes/assets/js/page-Objectis（）.8a1dcbd5.js"><link rel="prefetch" href="/notes/assets/js/page-Portals.74e82958.js"><link rel="prefetch" href="/notes/assets/js/page-ProgressEvent.f7448c52.js"><link rel="prefetch" href="/notes/assets/js/page-Promise.34f3fc7b.js"><link rel="prefetch" href="/notes/assets/js/page-Promise面试题总结.1c81e986.js"><link rel="prefetch" href="/notes/assets/js/page-Props(v2611).016f514e.js"><link rel="prefetch" href="/notes/assets/js/page-Quirks模式是什么？它和Standards模式有什么区别.ce16b478.js"><link rel="prefetch" href="/notes/assets/js/page-React+TypeScript规范.168a1516.js"><link rel="prefetch" href="/notes/assets/js/page-ReactComponent.0b0c3f82.js"><link rel="prefetch" href="/notes/assets/js/page-ReactJSX.2f25daba.js"><link rel="prefetch" href="/notes/assets/js/page-React引用传递ForwardingRefs.b8f91cae.js"><link rel="prefetch" href="/notes/assets/js/page-React源码解析.89a7ea93.js"><link rel="prefetch" href="/notes/assets/js/page-React高阶组件(HOC).d733170a.js"><link rel="prefetch" href="/notes/assets/js/page-ReflectMetadata.6042da5c.js"><link rel="prefetch" href="/notes/assets/js/page-Stack.d7726afd.js"><link rel="prefetch" href="/notes/assets/js/page-StickyFooter，完美的绝对底部.bfbf5173.js"><link rel="prefetch" href="/notes/assets/js/page-String.9ac9d226.js"><link rel="prefetch" href="/notes/assets/js/page-Suspense组件.53591122.js"><link rel="prefetch" href="/notes/assets/js/page-Symbol.b1304fd6.js"><link rel="prefetch" href="/notes/assets/js/page-ThisType.b9b678d5.js"><link rel="prefetch" href="/notes/assets/js/page-TransformBuildApi.ee59e24c.js"><link rel="prefetch" href="/notes/assets/js/page-Truthy.f7347367.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript37.5991d2e2.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript38.0450cee9.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript39.56cde250.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript中的静态构造函数.b0bdfeca.js"><link rel="prefetch" href="/notes/assets/js/page-VNode.13692fa3.js"><link rel="prefetch" href="/notes/assets/js/page-VirtualDOM.69acc64a.js"><link rel="prefetch" href="/notes/assets/js/page-Vue-Router.2f3fff4c.js"><link rel="prefetch" href="/notes/assets/js/page-VueRouter对象.15a3220c.js"><link rel="prefetch" href="/notes/assets/js/page-Vuejs源码构建.3b73fef8.js"><link rel="prefetch" href="/notes/assets/js/page-Vuejs源码目录设计.f79594eb.js"><link rel="prefetch" href="/notes/assets/js/page-Vuex.9580e4eb.js"><link rel="prefetch" href="/notes/assets/js/page-Vuex初始化.6d535100.js"><link rel="prefetch" href="/notes/assets/js/page-Vue事件API.194678a0.js"><link rel="prefetch" href="/notes/assets/js/page-Vue实例挂载的实现.437945dc.js"><link rel="prefetch" href="/notes/assets/js/page-Vue模板渲染的原理.36dfc03a.js"><link rel="prefetch" href="/notes/assets/js/page-Webpack.3a4ae3d5.js"><link rel="prefetch" href="/notes/assets/js/page-XMLHttpRequest.e8a7e9fd.js"><link rel="prefetch" href="/notes/assets/js/page-accesskey.06cc76cd.js"><link rel="prefetch" href="/notes/assets/js/page-arguments[]函数参数数组.3b6b5355.js"><link rel="prefetch" href="/notes/assets/js/page-babel编译原理.ba58d787.js"><link rel="prefetch" href="/notes/assets/js/page-before和after中双冒号和单冒号.bff55531.js"><link rel="prefetch" href="/notes/assets/js/page-beginWork.1c340e72.js"><link rel="prefetch" href="/notes/assets/js/page-codegen.f3348aa4.js"><link rel="prefetch" href="/notes/assets/js/page-coerceRef.307ff0f1.js"><link rel="prefetch" href="/notes/assets/js/page-commitAllHostEffects.a4f66961.js"><link rel="prefetch" href="/notes/assets/js/page-commitAllLifeCycles.aa4b053f.js"><link rel="prefetch" href="/notes/assets/js/page-commitBeforeMutationLifecycles.2c7b1155.js"><link rel="prefetch" href="/notes/assets/js/page-commitDeletion.202642a9.js"><link rel="prefetch" href="/notes/assets/js/page-commitPlacement.94e06440.js"><link rel="prefetch" href="/notes/assets/js/page-commitRoot.fa4c2f7d.js"><link rel="prefetch" href="/notes/assets/js/page-commitWork.11f408d3.js"><link rel="prefetch" href="/notes/assets/js/page-constructor和getInitialState.03b26a00.js"><link rel="prefetch" href="/notes/assets/js/page-createComponent.9f830b89.js"><link rel="prefetch" href="/notes/assets/js/page-createElement.567bd0cf.js"><link rel="prefetch" href="/notes/assets/js/page-css优先级：.9bea4810.js"><link rel="prefetch" href="/notes/assets/js/page-css兼容性整理.98eb022f.js"><link rel="prefetch" href="/notes/assets/js/page-css基础面试.e3c749b8.js"><link rel="prefetch" href="/notes/assets/js/page-demo.3f00c51f.js"><link rel="prefetch" href="/notes/assets/js/page-device.fb623572.js"><link rel="prefetch" href="/notes/assets/js/page-divonClick={handlerClick}单击单击div有什么区别.cce347dd.js"><link rel="prefetch" href="/notes/assets/js/page-es6module.03798894.js"><link rel="prefetch" href="/notes/assets/js/page-event.f6155143.js"><link rel="prefetch" href="/notes/assets/js/page-exportdefault被认为是有害的.f13cec5e.js"><link rel="prefetch" href="/notes/assets/js/page-function.789dc58a.js"><link rel="prefetch" href="/notes/assets/js/page-gitrebase.96ef44d9.js"><link rel="prefetch" href="/notes/assets/js/page-hydrate.818e67c5.js"><link rel="prefetch" href="/notes/assets/js/page-infer.50689893.js"><link rel="prefetch" href="/notes/assets/js/page-inline-block元素间间距.06d1d01f.js"><link rel="prefetch" href="/notes/assets/js/page-invokeGuardedCallback.7bc614ed.js"><link rel="prefetch" href="/notes/assets/js/page-js奇怪的小问题.a49ee8a2.js"><link rel="prefetch" href="/notes/assets/js/page-js异步历史.d541ac3f.js"><link rel="prefetch" href="/notes/assets/js/page-js总结.87ff9acd.js"><link rel="prefetch" href="/notes/assets/js/page-keep-alive.4dcd0e41.js"><link rel="prefetch" href="/notes/assets/js/page-lazycomponent.8ec09267.js"><link rel="prefetch" href="/notes/assets/js/page-libdts.d301b558.js"><link rel="prefetch" href="/notes/assets/js/page-loader.3c33b6b3.js"><link rel="prefetch" href="/notes/assets/js/page-matcher.9e44d4e5.js"><link rel="prefetch" href="/notes/assets/js/page-module、export、import分别有什么作用？.6886ca13.js"><link rel="prefetch" href="/notes/assets/js/page-mountIndeterminateComponent.fe5257bd.js"><link rel="prefetch" href="/notes/assets/js/page-mountLazyCompont.8e08a076.js"><link rel="prefetch" href="/notes/assets/js/page-newVue发生了什么.69456334.js"><link rel="prefetch" href="/notes/assets/js/page-nextTick.ab608248.js"><link rel="prefetch" href="/notes/assets/js/page-optimize.58c17109.js"><link rel="prefetch" href="/notes/assets/js/page-parse.0542fdb3.js"><link rel="prefetch" href="/notes/assets/js/page-patch.00c9415d.js"><link rel="prefetch" href="/notes/assets/js/page-plugin.a90a9801.js"><link rel="prefetch" href="/notes/assets/js/page-plugins.93e87635.js"><link rel="prefetch" href="/notes/assets/js/page-public设置.f274acc7.js"><link rel="prefetch" href="/notes/assets/js/page-react-dom.b57391d2.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks.2b589a97.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks使用.d1bf2b18.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks原理.c2635a0a.js"><link rel="prefetch" href="/notes/assets/js/page-react-redux源码.ea956518.js"><link rel="prefetch" href="/notes/assets/js/page-readonly.84637484.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileChildren.051630fe.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileChildrenArray.0ab175bb.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileSingleElement.93d091b2.js"><link rel="prefetch" href="/notes/assets/js/page-redux源码解读.5a6ecd1d.js"><link rel="prefetch" href="/notes/assets/js/page-render.26077659.js"><link rel="prefetch" href="/notes/assets/js/page-resolveCurrentlyRenderingFiber.c8e319b3.js"><link rel="prefetch" href="/notes/assets/js/page-set.2517acec.js"><link rel="prefetch" href="/notes/assets/js/page-setState.33cd9776.js"><link rel="prefetch" href="/notes/assets/js/page-setState执行流程.c554ba22.js"><link rel="prefetch" href="/notes/assets/js/page-setState背后的批量更新如何实现.0b360711.js"><link rel="prefetch" href="/notes/assets/js/page-slot.e8db7bfb.js"><link rel="prefetch" href="/notes/assets/js/page-suspense.e59f495f.js"><link rel="prefetch" href="/notes/assets/js/page-throwException.57e19b85.js"><link rel="prefetch" href="/notes/assets/js/page-transition-group.9bb05cf8.js"><link rel="prefetch" href="/notes/assets/js/page-transition.42438457.js"><link rel="prefetch" href="/notes/assets/js/page-tsconfigjson的行为.3e60d79c.js"><link rel="prefetch" href="/notes/assets/js/page-typescript综合面试.dd887718.js"><link rel="prefetch" href="/notes/assets/js/page-update.970c7cdf.js"><link rel="prefetch" href="/notes/assets/js/page-updateClassComponent.3f0e1680.js"><link rel="prefetch" href="/notes/assets/js/page-updateContextConsumer.10631ce7.js"><link rel="prefetch" href="/notes/assets/js/page-updateContextProvider.85103a61.js"><link rel="prefetch" href="/notes/assets/js/page-updateForwardRef.2f5adf43.js"><link rel="prefetch" href="/notes/assets/js/page-updateFragment.588d35bf.js"><link rel="prefetch" href="/notes/assets/js/page-updateFunctionalComponent.623982ed.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostComponent.6eeb22f1.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostRoot.55077df8.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostText.439ed0cd.js"><link rel="prefetch" href="/notes/assets/js/page-updateMode.d34f32bb.js"><link rel="prefetch" href="/notes/assets/js/page-updatePortalComponent.504918b6.js"><link rel="prefetch" href="/notes/assets/js/page-updateProfiler.1d43210e.js"><link rel="prefetch" href="/notes/assets/js/page-updateSuspenseComponent.d9de693f.js"><link rel="prefetch" href="/notes/assets/js/page-useCallbackuseMemo.2bea6142.js"><link rel="prefetch" href="/notes/assets/js/page-useContext.c27eb992.js"><link rel="prefetch" href="/notes/assets/js/page-useEffect.fabb8118.js"><link rel="prefetch" href="/notes/assets/js/page-useState.8e76bab9.js"><link rel="prefetch" href="/notes/assets/js/page-v-model.48eea062.js"><link rel="prefetch" href="/notes/assets/js/page-vue响应式详解（重学前端-vue篇1）.66421e8e.js"><link rel="prefetch" href="/notes/assets/js/page-vue的优点.3e597e35.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-1期】理解JavaScript中的执行上下文和执行栈.57f79c73.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-2期】JavaScript深入之执行上下文栈和变量对象.97797051.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-3期】JavaScript深入之内存空间详细图解.42df035b.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-4期】JavaScript深入之带走进内存机制.00d409c1.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-5期】JavaScript深入之4类常见内存泄漏及如何避免.7f3a7715.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-1期】深入浅出图解作用域链和闭包.570a4eb3.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-2期】JavaScript深入之从作用域链理解闭包.fd34eb22.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-3期】JavaScript深入之闭包面试题解.693d265c.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-1期】JavaScript深入之史上最全--5种this绑定全面解析.d0184eb5.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-2期】JavaScript深入之重新认识箭头函数的this.7ec3949f.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-3期】深度广度解析call和apply原理、使用场景及实现.5bafeafc.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-4期】深度解析bind原理、使用场景及模拟实现.ec3bf3cd.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-5期】深度解析new原理及模拟实现.ec60f4c3.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-1期】详细解析赋值、浅拷贝和深拷贝的区别.39791404.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-2期】Objectassign原理及其实现.6377631c.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-3期】面试题之如何实现一个深拷贝.24552c3d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-4期】Lodash是如何实现深拷贝的.41aa3243.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-1期】重新认识构造函数、原型和原型链.f0b694f1.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-2期】图解原型链及其继承优缺点.7e1ba335.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-3期】深入探究FunctionObject鸡蛋问题.c065e6cb.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-1期】JavaScript高阶函数浅析.8e51cb94.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-2期】深入高阶函数应用之柯里化.29aa3e7a.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-3期】Array原型方法源码实现大解密.829ffa37.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-1期】深入浅出节流函数throttle.a94bc4ac.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-2期】深入浅出防抖函数debounce.96351899.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-3期】Throttle和Debounce在React中的应用.dccd8dd2.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-4期】深入篇阿里P6必会Lodash防抖节流函数实现原理.dec5d22a.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-5期】浅出篇7个角度吃透Lodash防抖节流原理.0cd77284.js"><link rel="prefetch" href="/notes/assets/js/page-一、Webpack原理.84759607.js"><link rel="prefetch" href="/notes/assets/js/page-一、为什么JavaScript是单线程？.936b5bb6.js"><link rel="prefetch" href="/notes/assets/js/page-一、概述.20ba3882.js"><link rel="prefetch" href="/notes/assets/js/page-一、简介.5ac912c5.js"><link rel="prefetch" href="/notes/assets/js/page-一些不能按预期工作的代码.07c8517c.js"><link rel="prefetch" href="/notes/assets/js/page-一些常见的Feature需求.569f8889.js"><link rel="prefetch" href="/notes/assets/js/page-一些常见的「bug」并不是bug.61738d4d.js"><link rel="prefetch" href="/notes/assets/js/page-一正确理解react-router.b7facb2a.js"><link rel="prefetch" href="/notes/assets/js/page-严格模式.b6057397.js"><link rel="prefetch" href="/notes/assets/js/page-中介者模式.50d9215d.js"><link rel="prefetch" href="/notes/assets/js/page-事件模块的注入模式.89c70d38.js"><link rel="prefetch" href="/notes/assets/js/page-事件监听句柄.da4019fc.js"><link rel="prefetch" href="/notes/assets/js/page-事件绑定.e1ecd643.js"><link rel="prefetch" href="/notes/assets/js/page-事件触发.1eccc194.js"><link rel="prefetch" href="/notes/assets/js/page-从JavaScript迁移.541117ca.js"><link rel="prefetch" href="/notes/assets/js/page-从new一个Vue对象开始.18e7ec2f.js"><link rel="prefetch" href="/notes/assets/js/page-从入口开始.6675b5e8.js"><link rel="prefetch" href="/notes/assets/js/page-代理模式.9a30fff7.js"><link rel="prefetch" href="/notes/assets/js/page-代码分割.80812ed2.js"><link rel="prefetch" href="/notes/assets/js/page-代码分离.f12a6e23.js"><link rel="prefetch" href="/notes/assets/js/page-传参.c1a1892f.js"><link rel="prefetch" href="/notes/assets/js/page-伪元素.03d1734f.js"><link rel="prefetch" href="/notes/assets/js/page-伪类.db11596d.js"><link rel="prefetch" href="/notes/assets/js/page-作用.31dd836b.js"><link rel="prefetch" href="/notes/assets/js/page-依赖收集.5a0e01f1.js"><link rel="prefetch" href="/notes/assets/js/page-元素选择器.c89a104c.js"><link rel="prefetch" href="/notes/assets/js/page-入口起点(entrypoints).ff0f80f2.js"><link rel="prefetch" href="/notes/assets/js/page-全局属性：用于任何HTML5元素的属性.2d8d22c9.js"><link rel="prefetch" href="/notes/assets/js/page-关于ReactHooks.a9ae5de1.js"><link rel="prefetch" href="/notes/assets/js/page-具体使用.6bd615b6.js"><link rel="prefetch" href="/notes/assets/js/page-写一个方法去掉字符串中的空格.f6193ce6.js"><link rel="prefetch" href="/notes/assets/js/page-减少setter属性的使用.f95bd076.js"><link rel="prefetch" href="/notes/assets/js/page-函数.753b5999.js"><link rel="prefetch" href="/notes/assets/js/page-函数参数.4c874413.js"><link rel="prefetch" href="/notes/assets/js/page-函数式编程.0b1b6e4b.js"><link rel="prefetch" href="/notes/assets/js/page-创建event对象.42a297e1.js"><link rel="prefetch" href="/notes/assets/js/page-创建数组.673175b1.js"><link rel="prefetch" href="/notes/assets/js/page-动态导入表达式.2d98051d.js"><link rel="prefetch" href="/notes/assets/js/page-协变与逆变.d50df237.js"><link rel="prefetch" href="/notes/assets/js/page-单例模式.84317ddb.js"><link rel="prefetch" href="/notes/assets/js/page-原型模式.54b8a3c0.js"><link rel="prefetch" href="/notes/assets/js/page-原理图.2b5d377d.js"><link rel="prefetch" href="/notes/assets/js/page-发射器.bf8b18b5.js"><link rel="prefetch" href="/notes/assets/js/page-可能不需要使用派生state.0249dc4f.js"><link rel="prefetch" href="/notes/assets/js/page-可调用的.b48a6397.js"><link rel="prefetch" href="/notes/assets/js/page-合并配置.c1be67c9.js"><link rel="prefetch" href="/notes/assets/js/page-名义化类型.3d42a2f9.js"><link rel="prefetch" href="/notes/assets/js/page-后代选择器.9a408c37.js"><link rel="prefetch" href="/notes/assets/js/page-命令模式.a9001d19.js"><link rel="prefetch" href="/notes/assets/js/page-命令行的行为.372a828d.js"><link rel="prefetch" href="/notes/assets/js/page-命名空间.faa23253.js"><link rel="prefetch" href="/notes/assets/js/page-响应式对象.bd0bbfad.js"><link rel="prefetch" href="/notes/assets/js/page-块格式化上下文.bb0c2acd.js"><link rel="prefetch" href="/notes/assets/js/page-基于字符串的枚举.16c15157.js"><link rel="prefetch" href="/notes/assets/js/page-基本概念.610b448a.js"><link rel="prefetch" href="/notes/assets/js/page-基础分类.de4ab1a8.js"><link rel="prefetch" href="/notes/assets/js/page-声明空间.209a4bb6.js"><link rel="prefetch" href="/notes/assets/js/page-外观模式.2e12b644.js"><link rel="prefetch" href="/notes/assets/js/page-外边距重叠.5aed907c.js"><link rel="prefetch" href="/notes/assets/js/page-大文件上传和断点续传.75c4b42d.js"><link rel="prefetch" href="/notes/assets/js/page-如何关闭表单自动填充.449763b8.js"><link rel="prefetch" href="/notes/assets/js/page-子选择器.2fae857e.js"><link rel="prefetch" href="/notes/assets/js/page-字面量类型.56d80b26.js"><link rel="prefetch" href="/notes/assets/js/page-对象字面量的惰性初始化.dbd369fd.js"><link rel="prefetch" href="/notes/assets/js/page-层叠上下文.dbbcddb6.js"><link rel="prefetch" href="/notes/assets/js/page-展开语法.ed1a9a72.js"><link rel="prefetch" href="/notes/assets/js/page-展示长列表.df991080.js"><link rel="prefetch" href="/notes/assets/js/page-属性选择器.ae4af699.js"><link rel="prefetch" href="/notes/assets/js/page-工具类.20fa2a84.js"><link rel="prefetch" href="/notes/assets/js/page-工厂模式.7a1f93f4.js"><link rel="prefetch" href="/notes/assets/js/page-布局和包含块.f960b5d6.js"><link rel="prefetch" href="/notes/assets/js/page-常用块级元素：.2f254a9e.js"><link rel="prefetch" href="/notes/assets/js/page-常见的Error.54e99a82.js"><link rel="prefetch" href="/notes/assets/js/page-并发模型与事件循环.76de5276.js"><link rel="prefetch" href="/notes/assets/js/page-建造者模式.fab8f056.js"><link rel="prefetch" href="/notes/assets/js/page-开始.2277d93a.js"><link rel="prefetch" href="/notes/assets/js/page-异常处理.b4ee0a08.js"><link rel="prefetch" href="/notes/assets/js/page-异步组件.68ca9b0a.js"><link rel="prefetch" href="/notes/assets/js/page-引入.d47dacda.js"><link rel="prefetch" href="/notes/assets/js/page-引用.29635729.js"><link rel="prefetch" href="/notes/assets/js/page-引用官网.10a4c6d9.js"><link rel="prefetch" href="/notes/assets/js/page-总结.66956906.js"><link rel="prefetch" href="/notes/assets/js/page-惰性初始模式.64a55de9.js"><link rel="prefetch" href="/notes/assets/js/page-扩展.01059bbb.js"><link rel="prefetch" href="/notes/assets/js/page-扫描器.5bf93e50.js"><link rel="prefetch" href="/notes/assets/js/page-抽象DOM树.47a7e8ec.js"><link rel="prefetch" href="/notes/assets/js/page-抽象语法树.5337f1a6.js"><link rel="prefetch" href="/notes/assets/js/page-接口.a842b6e1.js"><link rel="prefetch" href="/notes/assets/js/page-插件.8211a7ed.js"><link rel="prefetch" href="/notes/assets/js/page-操作DOM.25e13c7a.js"><link rel="prefetch" href="/notes/assets/js/page-支持JSX.73d56a9c.js"><link rel="prefetch" href="/notes/assets/js/page-改善antdTable组件的渲染效率.0ac187e8.js"><link rel="prefetch" href="/notes/assets/js/page-数据绑定原理.411530ef.js"><link rel="prefetch" href="/notes/assets/js/page-数据驱动.841db928.js"><link rel="prefetch" href="/notes/assets/js/page-文档声明区别.0fa5103c.js"><link rel="prefetch" href="/notes/assets/js/page-新js环境要求.e4c7ad9b.js"><link rel="prefetch" href="/notes/assets/js/page-暴露模块模式.9a1b2492.js"><link rel="prefetch" href="/notes/assets/js/page-服务器基础.6f40a28d.js"><link rel="prefetch" href="/notes/assets/js/page-术语表.0df8989c.js"><link rel="prefetch" href="/notes/assets/js/page-构建切换.943dbad9.js"><link rel="prefetch" href="/notes/assets/js/page-构造器模式.00bff4da.js"><link rel="prefetch" href="/notes/assets/js/page-枚举.07e18bc5.js"><link rel="prefetch" href="/notes/assets/js/page-柯里化.b8448ad6.js"><link rel="prefetch" href="/notes/assets/js/page-标准的CSS的盒子模型？低版本IE的盒子模型.e3727a42.js"><link rel="prefetch" href="/notes/assets/js/page-检查器.f19e3907.js"><link rel="prefetch" href="/notes/assets/js/page-检测变化的注意事项.20df4c25.js"><link rel="prefetch" href="/notes/assets/js/page-概念.2f4d9e6e.js"><link rel="prefetch" href="/notes/assets/js/page-概览.84df806c.js"><link rel="prefetch" href="/notes/assets/js/page-模块.a172b28c.js"><link rel="prefetch" href="/notes/assets/js/page-模块化模式.4f39f998.js"><link rel="prefetch" href="/notes/assets/js/page-泛型.828afd2f.js"><link rel="prefetch" href="/notes/assets/js/page-泛型的实例化类型.7e829619.js"><link rel="prefetch" href="/notes/assets/js/page-派发更新.6630a1b2.js"><link rel="prefetch" href="/notes/assets/js/page-流动的类型.44d940a5.js"><link rel="prefetch" href="/notes/assets/js/page-浏览器输入URL.c2072a7a.js"><link rel="prefetch" href="/notes/assets/js/page-深入响应式原理.ddab2353.js"><link rel="prefetch" href="/notes/assets/js/page-深入源码剖析componentWillXXX为什么UNSAFE.d19fe97c.js"><link rel="prefetch" href="/notes/assets/js/page-混合.1b7debfc.js"><link rel="prefetch" href="/notes/assets/js/page-状态函数.9684220a.js"><link rel="prefetch" href="/notes/assets/js/page-环境声明.5568cef1.js"><link rel="prefetch" href="/notes/assets/js/page-生命周期.02500a04.js"><link rel="prefetch" href="/notes/assets/js/page-用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值.a6e10416.js"><link rel="prefetch" href="/notes/assets/js/page-相邻兄弟选择器.f6f48369.js"><link rel="prefetch" href="/notes/assets/js/page-知识体系.4c8e92e4.js"><link rel="prefetch" href="/notes/assets/js/page-程序.ee3e352c.js"><link rel="prefetch" href="/notes/assets/js/page-第10天简要描述下什么是回调函数并写一个例子出来.c80013c9.js"><link rel="prefetch" href="/notes/assets/js/page-第11天简要描述下JS有哪些内置的对象.a1560241.js"><link rel="prefetch" href="/notes/assets/js/page-第12天写一个获取当前url查询字符串中的参数的方法.857ad68f.js"><link rel="prefetch" href="/notes/assets/js/page-第13天说说你对javascript的作用域的理解.cf571273.js"><link rel="prefetch" href="/notes/assets/js/page-第14天什么是闭包？优缺点分别是什么？.81e801f1.js"><link rel="prefetch" href="/notes/assets/js/page-第15天写一个数组去重的方法（支持多维数组）.2595b8e8.js"><link rel="prefetch" href="/notes/assets/js/page-第16天返回到顶部的方法有哪些？把其中一个方法出来.afb07390.js"><link rel="prefetch" href="/notes/assets/js/page-第17天typeof('abc')和typeof'abc'都是string,那么typeof是操作符还是函数？.e8f17295.js"><link rel="prefetch" href="/notes/assets/js/page-第18天你理解的usestrict;是什么使用它有什么优缺点？.fb3fc88b.js"><link rel="prefetch" href="/notes/assets/js/page-第19天attribute和property有什么不同？.4a8b05e0.js"><link rel="prefetch" href="/notes/assets/js/page-第1天用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值.ec31f15d.js"><link rel="prefetch" href="/notes/assets/js/page-第20天写一个验证身份证号的方法.6f5bf22e.js"><link rel="prefetch" href="/notes/assets/js/page-第21天写一个方法验证是否为中文.3cafd49d.js"><link rel="prefetch" href="/notes/assets/js/page-第22天你对new操作符的理解是什么？手动实现一个new方法.e94f960e.js"><link rel="prefetch" href="/notes/assets/js/page-第23天01+02、01+03和0102分别等于多少？并解释下为什么？.5fcb5a6e.js"><link rel="prefetch" href="/notes/assets/js/page-第24天如何快速让一个数组乱序，写出来.0dc9971a.js"><link rel="prefetch" href="/notes/assets/js/page-第25天写一个判断设备来源的方法.609aec11.js"><link rel="prefetch" href="/notes/assets/js/page-第26天说说bind、call、apply的区别？并手写实现一个bind的方法.6fd8edc5.js"><link rel="prefetch" href="/notes/assets/js/page-第27天说说你对arguments的理解，它是数组吗？.fa77b8d6.js"><link rel="prefetch" href="/notes/assets/js/page-第28天解释下这段代码的意思！.6f23dc25.js"><link rel="prefetch" href="/notes/assets/js/page-第29天写一个获取数组的最大值、最小值的方法.4dbecac7.js"><link rel="prefetch" href="/notes/assets/js/page-第2天写一个方法去掉字符串中的空格.59557d1f.js"><link rel="prefetch" href="/notes/assets/js/page-第30天写一个方法判断字符串是否为回文字符串.a131163b.js"><link rel="prefetch" href="/notes/assets/js/page-第3天去除字符串中最后一个指定的字符.5358874d.js"><link rel="prefetch" href="/notes/assets/js/page-第4天写一个方法把下划线命名转成大驼峰命名.8ef8cc56.js"><link rel="prefetch" href="/notes/assets/js/page-第5天写一个把字符串大小写切换的方法.7d033130.js"><link rel="prefetch" href="/notes/assets/js/page-第6天写一个去除制表符和换行符的方法.6daac610.js"><link rel="prefetch" href="/notes/assets/js/page-第7天统计某一字符或字符串在另一个字符串中出现的次数.75c1e9be.js"><link rel="prefetch" href="/notes/assets/js/page-第8天写一个加密字符串的方法.4ef381e3.js"><link rel="prefetch" href="/notes/assets/js/page-第9天写一个判断数据类型的方法.65fc1aa9.js"><link rel="prefetch" href="/notes/assets/js/page-第一套js综合基础面试题.1e7d6bc9.js"><link rel="prefetch" href="/notes/assets/js/page-第一套webpack综合基础面试题.4c29846d.js"><link rel="prefetch" href="/notes/assets/js/page-管理资源.2d81ea7b.js"><link rel="prefetch" href="/notes/assets/js/page-类.470feeb5.js"><link rel="prefetch" href="/notes/assets/js/page-类型保护.15fcbcea.js"><link rel="prefetch" href="/notes/assets/js/page-类型兼容性.a0ea39ac.js"><link rel="prefetch" href="/notes/assets/js/page-类型守卫.7099af04.js"><link rel="prefetch" href="/notes/assets/js/page-类型安全的EventEmitter.b494e77d.js"><link rel="prefetch" href="/notes/assets/js/page-类型推断.33f06f1f.js"><link rel="prefetch" href="/notes/assets/js/page-类型断言.60673a84.js"><link rel="prefetch" href="/notes/assets/js/page-类型系统的行为.ea9a71f5.js"><link rel="prefetch" href="/notes/assets/js/page-类是有用的.050a97c4.js"><link rel="prefetch" href="/notes/assets/js/page-类选择器.d84b9c48.js"><link rel="prefetch" href="/notes/assets/js/page-索引签名.beef9547.js"><link rel="prefetch" href="/notes/assets/js/page-组件化.969d9ddc.js"><link rel="prefetch" href="/notes/assets/js/page-组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除.f6905207.js"><link rel="prefetch" href="/notes/assets/js/page-组件更新.35268ad3.js"><link rel="prefetch" href="/notes/assets/js/page-组件注册.59a2f7c3.js"><link rel="prefetch" href="/notes/assets/js/page-组件类.c8ad37c7.js"><link rel="prefetch" href="/notes/assets/js/page-组合模式.0c9ada37.js"><link rel="prefetch" href="/notes/assets/js/page-绑定器.4d59f3cc.js"><link rel="prefetch" href="/notes/assets/js/page-结论.bbdfc140.js"><link rel="prefetch" href="/notes/assets/js/page-编译.5a12d362.js"><link rel="prefetch" href="/notes/assets/js/page-编译上下文.860fa38b.js"><link rel="prefetch" href="/notes/assets/js/page-编译入口.6e4883bc.js"><link rel="prefetch" href="/notes/assets/js/page-网站favicon图标.7be14775.js"><link rel="prefetch" href="/notes/assets/js/page-自定义hooks.39704381.js"><link rel="prefetch" href="/notes/assets/js/page-获取localStorage和sessionStorage当前已存储大小.49a080bd.js"><link rel="prefetch" href="/notes/assets/js/page-虚拟DOM和DOM-diff.8592014a.js"><link rel="prefetch" href="/notes/assets/js/page-表单数据.5f91ff4c.js"><link rel="prefetch" href="/notes/assets/js/page-装饰器.41ef8843.js"><link rel="prefetch" href="/notes/assets/js/page-装饰模式.f0b13aa0.js"><link rel="prefetch" href="/notes/assets/js/page-观察者模式.e4349df3.js"><link rel="prefetch" href="/notes/assets/js/page-解析器.d495ad1d.js"><link rel="prefetch" href="/notes/assets/js/page-解读Errors.e8df298e.js"><link rel="prefetch" href="/notes/assets/js/page-计算属性VS侦听属性.1b79e0bc.js"><link rel="prefetch" href="/notes/assets/js/page-认识Flow.cb5076d8.js"><link rel="prefetch" href="/notes/assets/js/page-评论.0ca3d5c0.js"><link rel="prefetch" href="/notes/assets/js/page-详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景.1011acc1.js"><link rel="prefetch" href="/notes/assets/js/page-说说对SPA单页面的理解，它的优缺点分别是什么？.24e57af9.js"><link rel="prefetch" href="/notes/assets/js/page-调和的过程.c0018bf1.js"><link rel="prefetch" href="/notes/assets/js/page-调度原理.de50198c.js"><link rel="prefetch" href="/notes/assets/js/page-谨慎使用--outFile.c2f48359.js"><link rel="prefetch" href="/notes/assets/js/page-超链接target属性.e6d6044b.js"><link rel="prefetch" href="/notes/assets/js/page-路径切换.cd957f71.js"><link rel="prefetch" href="/notes/assets/js/page-路由注册.712752a1.js"><link rel="prefetch" href="/notes/assets/js/page-输出(output).219da618.js"><link rel="prefetch" href="/notes/assets/js/page-辨析联合类型.3c5818c0.js"><link rel="prefetch" href="/notes/assets/js/page-迭代协议.98fd7ecb.js"><link rel="prefetch" href="/notes/assets/js/page-迭代器模式.ec9420e6.js"><link rel="prefetch" href="/notes/assets/js/page-适配器模式.8212a1cd.js"><link rel="prefetch" href="/notes/assets/js/page-选择器列表.6267b99f.js"><link rel="prefetch" href="/notes/assets/js/page-通用兄弟选择器.f3c72256.js"><link rel="prefetch" href="/notes/assets/js/page-通过标签语义化优化SEO.b56f0cb4.js"><link rel="prefetch" href="/notes/assets/js/page-通配选择器.1ffd3e4f.js"><link rel="prefetch" href="/notes/assets/js/page-需求分析.368dc02b.js"><link rel="prefetch" href="/notes/assets/js/page-非ReactJSX.9a1d131e.js"><link rel="prefetch" href="/notes/assets/js/page-项目性能优化.2cbdcdc8.js"><link rel="prefetch" href="/notes/assets/js/page-🗿HEAD.6a79a5de.js"><link rel="prefetch" href="/notes/assets/js/vendors~flowchart.2c318cf9.js"><link rel="prefetch" href="/notes/assets/js/vendors~mermaid.9f12d4fa.js"><link rel="prefetch" href="/notes/assets/js/vendors~photo-swipe.cb1d0ca1.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.33b160dd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-navbar has-sidebar has-anchor"><header class="navbar"><!----> <div class="content__navbar-start"></div> <button title="Sidebar Button" class="sidebar-button"><span class="icon"></span></button> <a href="/notes/" class="home-link router-link-active"><!----> <!----> <span class="site-name can-hide">前端 学习</span></a> <!----> <div class="content__navbar-center"></div> <div class="links"><button tabindex="-1" aria-hidden="true" class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><ul class="themecolor-select"><label for="themecolor-select">Theme Color:</label> <li><span class="default-theme"></span></li> </ul> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">Theme Mode:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0 0 42.667-42.667V128a42.667 42.667 0 0 0-85.334 0v85.333A42.667 42.667 0 0 0 512 256zm384 213.333h-85.333a42.667 42.667 0 0 0 0 85.334H896a42.667 42.667 0 0 0 0-85.334zM256 512a42.667 42.667 0 0 0-42.667-42.667H128a42.667 42.667 0 0 0 0 85.334h85.333A42.667 42.667 0 0 0 256 512zm9.387-298.667a42.667 42.667 0 0 0-59.307 62.72l61.44 59.307a42.667 42.667 0 0 0 31.147 11.947 42.667 42.667 0 0 0 30.72-13.227 42.667 42.667 0 0 0 0-60.16zm459.946 133.974a42.667 42.667 0 0 0 29.44-11.947l61.44-59.307a42.667 42.667 0 0 0-57.6-62.72l-61.44 60.587a42.667 42.667 0 0 0 0 60.16 42.667 42.667 0 0 0 28.16 13.227zM512 768a42.667 42.667 0 0 0-42.667 42.667V896a42.667 42.667 0 0 0 85.334 0v-85.333A42.667 42.667 0 0 0 512 768zm244.48-79.36a42.667 42.667 0 0 0-59.307 61.44l61.44 60.587a42.667 42.667 0 0 0 29.44 11.946 42.667 42.667 0 0 0 30.72-12.8 42.667 42.667 0 0 0 0-60.586zm-488.96 0-61.44 59.307a42.667 42.667 0 0 0 0 60.586 42.667 42.667 0 0 0 30.72 12.8 42.667 42.667 0 0 0 28.587-10.666l61.44-59.307a42.667 42.667 0 0 0-59.307-61.44zM512 341.333A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 0 0-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 0 0-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js" class="dropdown-title"><span class="title"><!---->
        js
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/mozillajs/baseObject/symbol.html" class="nav-link"><!---->
  mozilla：基本对象
</a></li><li class="dropdown-item"><a href="/notes/jsInterview/baseInterview.html" class="nav-link"><!---->
  基础面试题
</a></li><li class="dropdown-item"><a href="/notes/js/stack/executionStack.html" class="nav-link"><!---->
  js 概念
</a></li><li class="dropdown-item"><a href="/notes/es6/interview1.html" class="nav-link"><!---->
  es6
</a></li><li class="dropdown-item"><a href="/notes/es7/interview1.html" class="nav-link"><!---->
  es7
</a></li><li class="dropdown-item"><a href="/notes/es8/interview1.html" class="nav-link"><!---->
  es8
</a></li><li class="dropdown-item"><a href="/notes/es9/interview1.html" class="nav-link"><!---->
  es9
</a></li><li class="dropdown-item"><a href="/notes/es10/interview1.html" class="nav-link"><!---->
  es10
</a></li><li class="dropdown-item"><a href="/notes/ts/jsx/support.html" class="nav-link"><!---->
  JSX
</a></li><li class="dropdown-item"><a href="/notes/ts/project/inDepthTs.html" class="nav-link"><!---->
  TypeScript 项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title"><!---->
        css
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/mozillaCss/reference/universalSelectors.html" class="nav-link"><!---->
  第 1 期：CSS API
</a></li><li class="dropdown-item"><a href="/notes/css/interview/baseCss.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html" class="dropdown-title"><span class="title"><!---->
        html
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/html/interview/linkImport.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="端" class="dropdown-title"><span class="title"><!---->
        端
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/browser/interview/baseInterview.html" class="nav-link"><!---->
  基础浏览器
</a></li><li class="dropdown-item"><a href="/notes/http/interview/baseInterview.html" class="nav-link"><!---->
  基础http
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title"><!---->
        工具
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/webpack/interview/webpackInterview.html" class="nav-link"><!---->
  webpack
</a></li><li class="dropdown-item"><a href="/notes/esbuild/description.html" class="nav-link"><!---->
  esbuild
</a></li><li class="dropdown-item"><a href="/notes/rollup/introduction.html" class="nav-link"><!---->
  rollup
</a></li><li class="dropdown-item"><a href="/notes/git/indx.html" class="nav-link"><!---->
  git
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title"><!---->
        react
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/ILoveDevelop/react/principle/base.html" class="nav-link"><!---->
  react 源码阅读 代码视角
</a></li><li class="dropdown-item"><a href="/notes/react/preparation/idea.html" class="nav-link"><!---->
  react 源码阅读 思想视角
</a></li><li class="dropdown-item"><a href="/notes/umi/interview/pluginDva.html" class="nav-link"><!---->
  umi
</a></li><li class="dropdown-item"><a href="/notes/reactInterview/interview1.html" class="nav-link"><!---->
  整理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue" class="dropdown-title"><span class="title"><!---->
        vue
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/vue/prepare/flow.html" class="nav-link"><!---->
  第 1 期：源码解读-准备工作
</a></li><li class="dropdown-item"><a href="/notes/vue/data-driven/_index.html" class="nav-link"><!---->
  第2期：源码解读-数据驱动
</a></li><li class="dropdown-item"><a href="/notes/vue/components/create-component.html" class="nav-link"><!---->
  第3期：源码解读-组件化
</a></li><li class="dropdown-item"><a href="/notes/vue/reactive/reactive-object.html" class="nav-link"><!---->
  第4期：源码解读-深入响应式原理
</a></li><li class="dropdown-item"><a href="/notes/vue/compile/entrance.html" class="nav-link"><!---->
  第5期：源码解读-编译
</a></li><li class="dropdown-item"><a href="/notes/vue/extend/event.html" class="nav-link"><!---->
  第6期：源码解读-扩展
</a></li><li class="dropdown-item"><a href="/notes/vue/vue-router/install.html" class="nav-link"><!---->
  第7期：源码解读-VueRouter
</a></li><li class="dropdown-item"><a href="/notes/vue/vuex/idex.html" class="nav-link"><!---->
  第8期：源码解读-Vuex
</a></li><li class="dropdown-item"><a href="/notes/vue/interview/baseInterview.html" class="nav-link"><!---->
  第9期：基础面试题
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法&amp;设计" class="dropdown-title"><span class="title"><!---->
        算法&amp;设计
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/algorithm/interview/baseInterview.html" class="nav-link"><!---->
  第 1 期：基础面试题
</a></li><li class="dropdown-item"><a href="/notes/design/overview.html" class="nav-link"><!---->
  设计模式
</a></li></ul></div></div></nav> <!----> <!----> <!----> <div class="content__navbar-end"></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <!----> <div class="content__sidebar-top"></div> <nav class="sidebar-nav-links"><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="js" class="dropdown-title"><span class="title"><!---->
      js
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/mozillajs/baseObject/symbol.html" class="nav-link"><!---->
  mozilla：基本对象
</a></li><li class="dropdown-item"><!----> <a href="/notes/jsInterview/baseInterview.html" class="nav-link"><!---->
  基础面试题
</a></li><li class="dropdown-item"><!----> <a href="/notes/js/stack/executionStack.html" class="nav-link"><!---->
  js 概念
</a></li><li class="dropdown-item"><!----> <a href="/notes/es6/interview1.html" class="nav-link"><!---->
  es6
</a></li><li class="dropdown-item"><!----> <a href="/notes/es7/interview1.html" class="nav-link"><!---->
  es7
</a></li><li class="dropdown-item"><!----> <a href="/notes/es8/interview1.html" class="nav-link"><!---->
  es8
</a></li><li class="dropdown-item"><!----> <a href="/notes/es9/interview1.html" class="nav-link"><!---->
  es9
</a></li><li class="dropdown-item"><!----> <a href="/notes/es10/interview1.html" class="nav-link"><!---->
  es10
</a></li><li class="dropdown-item"><!----> <a href="/notes/ts/jsx/support.html" class="nav-link"><!---->
  JSX
</a></li><li class="dropdown-item"><!----> <a href="/notes/ts/project/inDepthTs.html" class="nav-link"><!---->
  TypeScript 项目
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title"><!---->
      css
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/mozillaCss/reference/universalSelectors.html" class="nav-link"><!---->
  第 1 期：CSS API
</a></li><li class="dropdown-item"><!----> <a href="/notes/css/interview/baseCss.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="html" class="dropdown-title"><span class="title"><!---->
      html
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/html/interview/linkImport.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="端" class="dropdown-title"><span class="title"><!---->
      端
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/browser/interview/baseInterview.html" class="nav-link"><!---->
  基础浏览器
</a></li><li class="dropdown-item"><!----> <a href="/notes/http/interview/baseInterview.html" class="nav-link"><!---->
  基础http
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title"><!---->
      工具
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/webpack/interview/webpackInterview.html" class="nav-link"><!---->
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/notes/esbuild/description.html" class="nav-link"><!---->
  esbuild
</a></li><li class="dropdown-item"><!----> <a href="/notes/rollup/introduction.html" class="nav-link"><!---->
  rollup
</a></li><li class="dropdown-item"><!----> <a href="/notes/git/indx.html" class="nav-link"><!---->
  git
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title"><!---->
      react
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/ILoveDevelop/react/principle/base.html" class="nav-link"><!---->
  react 源码阅读 代码视角
</a></li><li class="dropdown-item"><!----> <a href="/notes/react/preparation/idea.html" class="nav-link"><!---->
  react 源码阅读 思想视角
</a></li><li class="dropdown-item"><!----> <a href="/notes/umi/interview/pluginDva.html" class="nav-link"><!---->
  umi
</a></li><li class="dropdown-item"><!----> <a href="/notes/reactInterview/interview1.html" class="nav-link"><!---->
  整理
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="vue" class="dropdown-title"><span class="title"><!---->
      vue
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/vue/prepare/flow.html" class="nav-link"><!---->
  第 1 期：源码解读-准备工作
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/data-driven/_index.html" class="nav-link"><!---->
  第2期：源码解读-数据驱动
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/components/create-component.html" class="nav-link"><!---->
  第3期：源码解读-组件化
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/reactive/reactive-object.html" class="nav-link"><!---->
  第4期：源码解读-深入响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/compile/entrance.html" class="nav-link"><!---->
  第5期：源码解读-编译
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/extend/event.html" class="nav-link"><!---->
  第6期：源码解读-扩展
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/vue-router/install.html" class="nav-link"><!---->
  第7期：源码解读-VueRouter
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/vuex/idex.html" class="nav-link"><!---->
  第8期：源码解读-Vuex
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/interview/baseInterview.html" class="nav-link"><!---->
  第9期：基础面试题
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="算法&amp;设计" class="dropdown-title"><span class="title"><!---->
      算法&amp;设计
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/algorithm/interview/baseInterview.html" class="nav-link"><!---->
  第 1 期：基础面试题
</a></li><li class="dropdown-item"><!----> <a href="/notes/design/overview.html" class="nav-link"><!---->
  设计模式
</a></li></ul></div></div> <!----></nav> <!----> <div class="content__sidebar-center"></div> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><!----> <span class="title">TypeScript 项目</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/ts/project/inDepthTs/" aria-current="page" class="active sidebar-link">深入TypeScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#第一部分-前置内容" class="sidebar-link">第一部分 前置内容</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#extends关键词特性-重点" class="sidebar-link heading3">extends关键词特性（重点）</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#分配条件类型" class="sidebar-link heading3">分配条件类型</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#类型兼容性" class="sidebar-link heading3">类型兼容性</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#条件类型中的类型推断" class="sidebar-link heading3">条件类型中的类型推断</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#第二部分-ts内置类型工具原理解析" class="sidebar-link">第二部分 Ts内置类型工具原理解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#partial实现原理解析" class="sidebar-link heading3">Partial实现原理解析</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#readonly原理解析" class="sidebar-link heading3">Readonly原理解析</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#pick" class="sidebar-link heading3">Pick</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#record" class="sidebar-link heading3">Record</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#exclude原理解析" class="sidebar-link heading3">Exclude原理解析</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#extract" class="sidebar-link heading3">Extract</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#omit原理解析" class="sidebar-link heading3">Omit原理解析</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#parameters-和-returntype" class="sidebar-link heading3">Parameters 和 ReturnType</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#constructorparameters" class="sidebar-link heading3">ConstructorParameters</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#ts-compiler内部实现的类型" class="sidebar-link heading3">Ts compiler内部实现的类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#第三部分-自定义ts高级类型工具及类型编程技巧" class="sidebar-link">第三部分 自定义Ts高级类型工具及类型编程技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#symmetricdifference" class="sidebar-link heading3">SymmetricDifference</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#functionkeys" class="sidebar-link heading3">FunctionKeys</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#mutablekeys" class="sidebar-link heading3">MutableKeys</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#optionalkeys" class="sidebar-link heading3">OptionalKeys</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#增强pick" class="sidebar-link heading3">增强Pick</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#intersection" class="sidebar-link heading3">Intersection</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#overwrite-和-assign" class="sidebar-link heading3">Overwrite 和 Assign</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#deeprequired" class="sidebar-link heading3">DeepRequired</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#deepreadonlyarray" class="sidebar-link heading3">DeepReadonlyArray</a></li><li class="sidebar-sub-header"><a href="/notes/ts/project/inDepthTs/#uniontointersection" class="sidebar-link heading3">UnionToIntersection</a></li></ul></li></ul></li><li><a href="/notes/ts/project/compilationContext/" class="sidebar-link">编译上下文</a></li><li><a href="/notes/ts/project/declarationspaces/" class="sidebar-link">声明空间</a></li><li><a href="/notes/ts/project/modules/" class="sidebar-link">模块</a></li><li><a href="/notes/ts/project/namespaces/" class="sidebar-link">命名空间</a></li><li><a href="/notes/ts/project/dynamicImportExpressions/" class="sidebar-link">动态导入表达式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">TypeScript 类型系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">JSX</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">TypeScript 错误提示</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">TIPs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">TypeScript 编译原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">TypeScript FAQs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">版本差异</span> <span class="arrow right"></span></p> <!----></section></li></ul> <!----> <div class="content__sidebar-bottom"></div> <!----></aside> <main class="page"><nav class="breadcrumb disable"><!----></nav> <!----> <div class="content__page-top"></div> <div vocab="https://schema.org/" typeof="Article" class="page-title"><h1><!----> <span property="headline">深入TypeScript</span></h1> <div class="page-info"><!----> <!----><!----><span aria-label="Writing Date📅" data-balloon-pos="down" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H180.6A134.314 134.314 0 0 0 46.66 277.595v535.756A134.314 134.314 0 0 0 180.6 947.289h669.74a134.36 134.36 0 0 0 133.94-133.938V277.595a134.314 134.314 0 0 0-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 0 1-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 0 1-33.472 33.473z" fill="currentColor"></path></svg> <span property="datePublished">2021-9-14</span></span><!----><!----><span aria-label="Reading Time⌛" data-balloon-pos="down" class="reading-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon timer-icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z" fill="currentColor"></path></svg> <span>About 32 min</span> <meta property="timeRequired" content="PT32M"></span></div> <!----> <hr></div> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor"><a href="/notes/ts/project/inDepthTs/#第一部分-前置内容" class="anchor-link heading2"><div>第一部分 前置内容</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#extends关键词特性-重点" class="anchor-link heading3"><div>extends关键词特性（重点）</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#分配条件类型" class="anchor-link heading3"><div>分配条件类型</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#类型兼容性" class="anchor-link heading3"><div>类型兼容性</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#条件类型中的类型推断" class="anchor-link heading3"><div>条件类型中的类型推断</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#第二部分-ts内置类型工具原理解析" class="anchor-link heading2"><div>第二部分 Ts内置类型工具原理解析</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#partial实现原理解析" class="anchor-link heading3"><div>Partial实现原理解析</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#readonly原理解析" class="anchor-link heading3"><div>Readonly原理解析</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#pick" class="anchor-link heading3"><div>Pick</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#record" class="anchor-link heading3"><div>Record</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#exclude原理解析" class="anchor-link heading3"><div>Exclude原理解析</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#extract" class="anchor-link heading3"><div>Extract</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#omit原理解析" class="anchor-link heading3"><div>Omit原理解析</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#parameters-和-returntype" class="anchor-link heading3"><div>Parameters 和 ReturnType</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#constructorparameters" class="anchor-link heading3"><div>ConstructorParameters</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#ts-compiler内部实现的类型" class="anchor-link heading3"><div>Ts compiler内部实现的类型</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#第三部分-自定义ts高级类型工具及类型编程技巧" class="anchor-link heading2"><div>第三部分 自定义Ts高级类型工具及类型编程技巧</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#symmetricdifference" class="anchor-link heading3"><div>SymmetricDifference</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#functionkeys" class="anchor-link heading3"><div>FunctionKeys</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#mutablekeys" class="anchor-link heading3"><div>MutableKeys</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#optionalkeys" class="anchor-link heading3"><div>OptionalKeys</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#增强pick" class="anchor-link heading3"><div>增强Pick</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#intersection" class="anchor-link heading3"><div>Intersection</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#overwrite-和-assign" class="anchor-link heading3"><div>Overwrite 和 Assign</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#deeprequired" class="anchor-link heading3"><div>DeepRequired</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#deepreadonlyarray" class="anchor-link heading3"><div>DeepReadonlyArray</div></a></li><li class="anchor"><a href="/notes/ts/project/inDepthTs/#uniontointersection" class="anchor-link heading3"><div>UnionToIntersection</div></a></li></ul></div></aside></div> <!----> <div class="content__content-top"></div> <div class="theme-default-content content__default"><h1 id="深入typescript"><a href="#深入typescript" class="header-anchor">#</a> 深入TypeScript</h1> <h2 id="第一部分-前置内容"><a href="#第一部分-前置内容" class="header-anchor">#</a> 第一部分 前置内容</h2> <ul><li><code>keyof</code> 索引查询</li></ul> <p>对应任何类型<code>T</code>,<code>keyof T</code>的结果为该类型上所有共有属性key的联合：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token comment">// T1的类型实则是name | age</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Eg1

<span class="token keyword">class</span> <span class="token class-name">Eg2</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">protected</span> home<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// T2实则被约束为 age</span>
<span class="token comment">// 而name和home不是公有属性，所以不能被keyof获取到</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Eg2
</code></pre></div><ul><li><code>T[K]</code> 索引访问</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V1</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>
<span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V2</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'age'</span><span class="token punctuation">]</span>
<span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V2</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'age2222'</span><span class="token punctuation">]</span>
<span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">V3</span></span> <span class="token operator">=</span> Eg1<span class="token punctuation">[</span><span class="token keyword">keyof</span> Eg1<span class="token punctuation">]</span>
</code></pre></div><p><code>T[keyof T]</code>的方式，可以获取到<code>T</code>所有<code>key</code>的类型组成的联合类型；<code>T[keyof K]</code>的方式，获取到的是<code>T</code>中的<code>key</code>且同时存在于<code>K</code>时的类型组成的联合类型；注意：如果<code>[]</code>中的<code>key</code>有不存在<code>T</code>中的，则是<code>any</code>；因为<code>ts</code>也不知道该<code>key</code>最终是什么类型，所以是<code>any</code>；且也会报错；</p> <ul><li><code>&amp;</code> 交叉类型注意点</li></ul> <p>交叉类型取的多个类型的并集，但是如果相同<code>key</code>但是类型不同，则该<code>key</code>为<code>never</code>。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Eg1</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Eg2</span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * T的类型为 {name: string; age: number; age: never}
 * 注意，age因为Eg1和Eg2中的类型不一致，所以交叉后age的类型是never
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> Eg1 <span class="token operator">&amp;</span> Eg2
<span class="token comment">// 可通过如下示例验证</span>
<span class="token keyword">const</span> val<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  color<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="extends关键词特性-重点"><a href="#extends关键词特性-重点" class="header-anchor">#</a> extends关键词特性（重点）</h3> <ul><li>用于接口，表示继承</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">{</span>
  sex<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * @example
 * T3 = {name: string, sex: number, age: number}
 */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">T1</span></span><span class="token punctuation">,</span> <span class="token constant">T2</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意，接口支持多重继承，语法为逗号隔开。如果是<code>type</code>实现继承，则可以使用交叉类型<code>type A = B &amp; C &amp; D</code>。</p> <ul><li>表示条件类型，可用于条件判断</li></ul> <p>表示条件判断，如果前面的条件满足，则返回问号后的第一个参数，否则第二个。类似于js的三元运算。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">/**
 * @example
 * type A1 = 1
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> <span class="token string">'x'</span> <span class="token keyword">extends</span> <span class="token string">'x'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type A2 = 2
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> <span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span> <span class="token keyword">extends</span> <span class="token string">'x'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type A3 = 1 | 2
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">P</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token string">'x'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A3</span></span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token operator">&gt;</span>
</code></pre></div><p>提问：为什么<code>A2</code>和<code>A3</code>的值不一样？</p> <ul><li><p>如果用于简单的条件判断，则是直接判断前面的类型是否可分配给后面的类型</p></li> <li><p>若<code>extends</code>前面的类型是泛型，且泛型传入的是联合类型时，则会依次判断该联合类型的所有子类型是否可分配给<code>extends</code>后面的类型（是一个分发的过程）。</p></li></ul> <p><strong>总结，就是<code>extends</code>前面的参数为联合类型时则会分解（依次遍历所有的子类型进行条件判断）联合类型进行判断。然后将最终的结果组成新的联合类型。</strong></p> <ul><li>阻止<code>extends</code>关键词对于联合类型的分发特性</li></ul> <p>如果不想被分解（分发），做法也很简单，可以通过简单的元组类型包裹以下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">P</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">/**
 * type A4 = 2;
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A4</span></span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token operator">&gt;</span>
</code></pre></div><h3 id="分配条件类型"><a href="#分配条件类型" class="header-anchor">#</a> 分配条件类型</h3> <p>当条件类型作用于泛型类型时，当给定联合类型时，它们会变成分布式的。例如，采取以下措施：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ToArray<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre></div><p>如果将联合类型插入<code>ToArray</code>，则条件类型将应用于该联合的每个成员。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ToArray<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
 
<span class="token keyword">type</span> <span class="token class-name">StrArrOrNumArr</span> <span class="token operator">=</span> ToArray<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type StrArrOrNumArr = string[] | number[]</span>
<span class="token comment">// type ToArray&lt;type&gt; = Type extends any ? Type[] : never</span>
<span class="token comment">// (type parameter) Type in type ToArray&lt;Type&gt;</span>
</code></pre></div><p>这里发生的是<code>StrOrNumArray</code>分布于：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre></div><p>并映射到联合的每个成员类型，有效地：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>ToArray<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">|</span> ToArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// type ToArray&lt;type&gt; = Type extends any ? Type[] : never</span>
</code></pre></div><p>这给留下了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>通常，分配性是所需的行为。为避免这种行为，您可以<code>extends</code>用方括号将关键字的每一侧括起来。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ToArrayNonDist<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>Type<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">any</span><span class="token punctuation">]</span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
 
<span class="token comment">// 'StrOrNumArr' is no longer a union.</span>
<span class="token keyword">type</span> <span class="token class-name">StrOrNumArr</span> <span class="token operator">=</span> ToArrayNonDist<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type StrOrNumArr = (string | number)[]</span>
</code></pre></div><h3 id="类型兼容性"><a href="#类型兼容性" class="header-anchor">#</a> 类型兼容性</h3> <blockquote><p>集合论中，如果一个集合的所有元素在集合B中都存在，则A是B的子集；
类型系统中，如果一个类型的属性更具体，则该类型是子类型。（因为属性更少则说明该类型约束的更宽泛，是父类型）</p></blockquote> <p><strong>因此，可以得出基本的结论：子类型比父类型更加具体,父类型比子类型更宽泛。</strong> 下面也将基于类型的可复制性（可分配性）、协变、逆变、双向协变等进行进一步的讲解。</p> <ul><li>可赋值性</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> Dog<span class="token punctuation">;</span>

<span class="token comment">// 可以赋值，子类型更佳具体，可以赋值给更佳宽泛的父类型</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token comment">// 反过来不行</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre></div><ul><li>可赋值性在联合类型中的特性</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>

<span class="token comment">// 不可赋值</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token comment">// 可以赋值</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre></div><p>是不是<code>A</code>的类型更多，<code>A</code>就是子类型呢？恰恰相反，<code>A</code>此处类型更多但是其表达的类型更宽泛，所以<code>A</code>是父类型，<code>B</code>是子类型。</p> <p>因此<code>b = a</code>不成立（父类型不能赋值给子类型），而<code>a = b</code>成立（子类型可以赋值给父类型）。</p> <ul><li>协变</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> Eg1<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> Eg2<span class="token operator">:</span> Dog<span class="token punctuation">;</span>
<span class="token comment">// 兼容，可以赋值</span>
Eg1 <span class="token operator">=</span> Eg2<span class="token punctuation">;</span>

<span class="token keyword">let</span> Eg3<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span>
<span class="token keyword">let</span> Eg4<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span>
<span class="token comment">// 兼容，可以赋值</span>
Eg3 <span class="token operator">=</span> Eg4
</code></pre></div><p>通过<code>Eg3</code>和<code>Eg4</code>来看，在<code>Animal</code>和<code>Dog</code>在变成数组后，<code>Array&lt;Dog&gt;</code>依旧可以赋值给<code>Array&lt;Animal&gt;</code>，因此对于<code>type MakeArray = Array&lt;any&gt;</code>来说就是协变的。</p> <p>最后引用维基百科中的定义：</p> <blockquote><p>协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote> <p>简单说就是，具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了（子变父，父变子）就是逆变的。可能听起来有些抽象，下面将用更具体的例子进行演示说明：</p> <ul><li>逆变</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">AnimalFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token keyword">type</span> <span class="token class-name">DogFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>

<span class="token keyword">let</span> Eg1<span class="token operator">:</span> AnimalFn<span class="token punctuation">;</span>
<span class="token keyword">let</span> Eg2<span class="token operator">:</span> DogFn<span class="token punctuation">;</span>
<span class="token comment">// 不再可以赋值了，</span>
<span class="token comment">// AnimalFn = DogFn不可以赋值了, Animal = Dog是可以的</span>
Eg1 <span class="token operator">=</span> Eg2<span class="token punctuation">;</span>
<span class="token comment">// 反过来可以</span>
Eg2 <span class="token operator">=</span> Eg1<span class="token punctuation">;</span>
</code></pre></div><p>理论上，<code>Animal = Dog</code>是类型安全的，那么<code>AnimalFn = DogFn</code>也应该类型安全才对，为什么Ts认为不安全呢？看下面的例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> animal<span class="token operator">:</span> <span class="token function-variable function">AnimalFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> dog<span class="token operator">:</span> <span class="token function-variable function">DogFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  arg<span class="token punctuation">.</span><span class="token function">break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 假设类型安全可以赋值</span>
animal <span class="token operator">=</span> dog<span class="token punctuation">;</span>
<span class="token comment">// 那么animal在调用时约束的参数，缺少dog所需的参数，此时会导致错误</span>
<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'cat'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从这个例子看到，如果dog函数赋值给animal函数，那么animal函数在调用时，约束的是参数必须要为Animal类型（而不是Dog），但是animal实际为dog的调用，此时就会出现错误。</p> <p>因此，<code>Animal</code>和<code>Dog</code>在进行<code>type Fn&lt;T&gt; = (arg: T) =&gt; void</code>构造器构造后，父子关系逆转了，此时成为“逆变”。</p> <ul><li>双向协变</li></ul> <p>Ts在函数参数的比较中实际上默认采取的策略是双向协变：只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。</p> <p>这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息（典型的就是上述的逆变）。 但是实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// lib.dom.d.ts中EventListener的接口定义</span>
<span class="token keyword">interface</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>evt<span class="token operator">:</span> Event<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简化后的Event</span>
<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> target<span class="token operator">:</span> EventTarget <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简化合并后的MouseEvent</span>
<span class="token keyword">interface</span> <span class="token class-name">MouseEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 简化后的Window接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token comment">// 简化后的addEventListener</span>
  <span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> listener<span class="token operator">:</span> EventListener<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 日常使用</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mouseover'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到<code>Window</code>的<code>listener</code>函数要求参数是<code>Event</code>，但是日常使用时更多时候传入的是<code>Event</code>子类型。但是这里可以正常使用，正是其默认行为是双向协变的原因。可以通过<code>tsconfig.js</code>中修改<code>strictFunctionType</code>属性来严格控制协变和逆变。</p> <p><code>infer</code>关键词的功能暂时先不做太详细的说明了，主要是用于<code>extends</code>的条件类型中让Ts自己推到类型，具体的可以查阅官网。但是关于<code>infer</code>的一些容易让人忽略但是非常重要的特性，这里必须要提及一下：</p> <ul><li><code>infer</code>推导的名称相同并且都处于<strong>逆变</strong>的位置，则推导的结果将会是<strong>交叉类型</strong>。</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Bar<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">// type T1 = string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// type T2 = never</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="条件类型中的类型推断"><a href="#条件类型中的类型推断" class="header-anchor">#</a> 条件类型中的类型推断</h3> <p>在<code>extends</code>条件类型的子句中，现在可以有<code>infer</code>引入要推断的类型变量的声明。可以在条件类型的真实分支中引用此类推断类型变量。<code>infer</code>同一个类型变量可以有多个位置。</p> <p>例如，以下提取函数类型的返回类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><p>条件类型可以嵌套以形成按顺序评估的模式匹配序列：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Unpacked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">U</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Promise&lt;string&gt;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span>Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre></div><p>以下示例演示了协变位置中同一类型变量的多个候选者如何导致推断联合类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Foo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
</code></pre></div><p>同样，逆变位置中同一类型变量的多个候选会导致推断出交叉类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Bar<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string &amp; number</span>
</code></pre></div><p>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，会从最后一个签名（这可能是最宽松的包罗万象的情况）进行推断。无法根据参数类型列表执行重载决议。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T30</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
</code></pre></div><p>不能<code>infer</code>在常规类型参数的约束子句中使用声明：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">;</span> <span class="token comment">// Error, not supported</span>
</code></pre></div><p>但是，通过删除约束中的类型变量并指定条件类型，可以获得大致相同的效果：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">AnyFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> AnyFunction<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span>
  <span class="token operator">?</span> <span class="token constant">R</span>
  <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="第二部分-ts内置类型工具原理解析"><a href="#第二部分-ts内置类型工具原理解析" class="header-anchor">#</a> 第二部分 Ts内置类型工具原理解析</h2> <h3 id="partial实现原理解析"><a href="#partial实现原理解析" class="header-anchor">#</a> Partial实现原理解析</h3> <p><code>Partial&lt;T&gt;</code>将<code>T</code>的所有属性变成可选的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现就是通过映射类型遍历T上所有的属性，
 * 然后将每个属性设置为可选属性
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><code>[P in keyof T]</code>通过映射类型，遍历<code>T</code>上的所有属性</p></li> <li><p><code>?:</code>设置为属性为可选的</p></li> <li><p><code>T[P]</code>设置类型为原来的类型</p></li></ul> <p>扩展一下，将制定的<code>key</code>变成可选类型:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 主要通过K extends keyof T约束K必须为keyof T的子类型
 * keyof T得到的是T的所有key组成的联合类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PartialOptional<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * @example
 *     type Eg1 = { key1?: string; key2?: number }
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> PartialOptional<span class="token operator">&lt;</span><span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  key3<span class="token operator">:</span> <span class="token string">''</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'key1'</span> <span class="token operator">|</span> <span class="token string">'key2'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="readonly原理解析"><a href="#readonly原理解析" class="header-anchor">#</a> Readonly原理解析</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 主要实现是通过映射遍历所有key，
 * 然后给每个key增加一个readonly修饰符
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * @example
 * type Eg = {
 *   readonly key1: string;
 *   readonly key2: number;
 * }
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span><span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><h3 id="pick"><a href="#pick" class="header-anchor">#</a> Pick</h3> <p>挑选一组属性并组成一个新的类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>基本和上述同样的知识点，就不再赘述了。</p> <h3 id="record"><a href="#record" class="header-anchor">#</a> Record</h3> <p>构造一个<code>type</code>，<code>key</code>为联合类型中的每个子类型，类型为<code>T</code>。文字不好理解，先看例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @example
 * type Eg1 = {
 *   a: { key1: string; };
 *   b: { key1: string; };
 * }
 * @desc 就是遍历第一个参数'a' | 'b'的每个子类型，然后将值设置为第二参数
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><p>Record具体实现：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现就是遍历K，将值设置为T
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * @example
 * type Eg2 = {a: B, b: B}
 */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>值得注意的是<code>keyof any</code>得到的是<code>string | number | symbol</code></p></li> <li><p>原因在于类型key的类型只能为<code>string | number | symbol</code></p></li></ul> <p><strong>扩展: 同态与非同态</strong></p> <ul><li><code>Partial</code>、<code>Readonly</code>和<code>Pick</code>都属于同态的，即其实现需要输入类型T来拷贝属性，因此属性修饰符（例如readonly、?:）都会被拷贝。可从下面例子验证：</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @example
 * type Eg = {readonly a?: string}
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token operator">&gt;</span>
</code></pre></div><p>从<code>Eg</code>的结果可以看到，Pick在拷贝属性时，连带拷贝了<code>readonly</code>和<code>?:</code>的修饰符。</p> <ul><li><code>Record</code>是非同态的，不需要拷贝属性，因此不会拷贝属性修饰符</li></ul> <p>为什么<code>Pick</code>拷贝了属性，而<code>Record</code>没有拷贝？来对比一下其实现：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到<code>Pick</code>的实现中，注意<code>P in K</code>（本质是<code>P in keyof T</code>），T为输入的类型，而<code>keyof T</code>则遍历了输入类型；而<code>Record</code>的实现中，并没有遍历所有输入的类型，K只是约束为<code>keyof any</code>的子类型即可。</p> <p>最后再类比一下<code>Pick</code>、<code>Partial</code>、<code>readonly</code>这几个类型工具，无一例外，都是使用到了<code>keyof T</code>来辅助拷贝传入类型的属性。</p> <h3 id="exclude原理解析"><a href="#exclude原理解析" class="header-anchor">#</a> Exclude原理解析</h3> <p><code>Exclude&lt;T, U&gt;</code>提取存在于<code>T</code>，但不存在于<code>U</code>的类型组成的联合类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 遍历T中的所有子类型，如果该子类型约束于U（存在于U、兼容于U），
 * 则返回never类型，否则返回该子类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Exclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg = 'key1'
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">'key1'</span> <span class="token operator">|</span> <span class="token string">'key2'</span><span class="token punctuation">,</span> <span class="token string">'key2'</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p><code>never</code>表示一个不存在的类型</p></li> <li><p><code>never</code>与其他类型的联合后，是没有<code>never</code>的</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @example
 * type Eg2 = string | number
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">never</span>
</code></pre></div><p>因此上述<code>Eg</code>其实就等于<code>key1 | never</code>,也就是<code>type Eg = key1</code></p> <h3 id="extract"><a href="#extract" class="header-anchor">#</a> Extract</h3> <p><code>Extract&lt;T, U&gt;</code>提取联合类型T和联合类型U的所有交集。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Extract<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 *  type Eg = 'key1'
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">'key1'</span> <span class="token operator">|</span> <span class="token string">'key2'</span><span class="token punctuation">,</span> <span class="token string">'key1'</span><span class="token operator">&gt;</span>
</code></pre></div><h3 id="omit原理解析"><a href="#omit原理解析" class="header-anchor">#</a> Omit原理解析</h3> <p><code>Omit&lt;T, K&gt;</code>从类型<code>T</code>中剔除<code>K</code>中的所有属性。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 利用Pick实现Omit
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Omit</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>换种思路想一下，其实现可以是利用<code>Pick</code>提取我们需要的keys组成的类型</p></li> <li><p>因此也就是 <code>Omit = Pick&lt;T, 我们需要的属性联合&gt;</code></p></li> <li><p>而我们需要的属性联合就是，从T的属性联合中排出存在于联合类型K中的</p></li> <li><p>因此也就是<code>Exclude&lt;keyof T, K&gt;</code>;</p></li></ul> <p>如果不利用Pick实现呢?</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 利用映射类型Omit
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Omit2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>其实现类似于<code>Pick</code>的原理实现</p></li> <li><p>区别在于是遍历的我们需要的属性不一样</p></li> <li><p>我们需要的属性和上面的例子一样，就是<code>Exclude&lt;keyof T, K&gt;</code></p></li> <li><p>因此，遍历就是<code>[P in Exclude&lt;keyof T, K&gt;]</code></p></li></ul> <h3 id="parameters-和-returntype"><a href="#parameters-和-returntype" class="header-anchor">#</a> Parameters 和 ReturnType</h3> <p><strong>Parameters 获取函数的参数类型，将每个参数类型放在一个元组中。</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc 具体实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Parameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg = [arg1: string, arg2: number];
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span><span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p><code>Parameters</code>首先约束参数<code>T</code>必须是个函数类型，所以<code>(...args: any) =&gt; any&gt;</code>替换成<code>Function</code>也是可以的</p></li> <li><p>具体实现就是，判断<code>T</code>是否是函数类型，如果是则使用<code>inter P</code>让ts自己推导出函数的参数类型，并将推导的结果存到类型<code>P</code>上，否则就返回<code>never</code>；</p></li></ul> <blockquote><ul><li><p><code>infer</code>关键词作用是让Ts自己推导类型，并将推导结果存储在其参数绑定的类型上。Eg:<code>infer P</code> 就是将结果存在类型<code>P</code>上，供使用。</p></li> <li><p><code>infer</code>关键词只能在<code>extends</code>条件类型上使用，不能在其他地方使用。</p></li></ul></blockquote> <p><strong>注意</strong></p> <ul><li><p><code>type Eg = [arg1: string, arg2: number]</code>这是一个元组，但是和我们常见的元组<code>type tuple = [string, number]</code>。官网未提到该部分文档说明，其实可以把这个作为类似命名元组，或者具名元组的意思去理解。实质上没有什么特殊的作用，比如无法通过这个具名去取值不行的。但是从语义化的角度，个人觉得多了语义化的表达罢了。</p></li> <li><p>定义元祖的可选项，只能是最后的选项</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 普通方式
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a<span class="token operator">:</span> Tuple1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a2<span class="token operator">:</span> Tuple1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aa'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 具名方式
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple2</span> <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span> Tuple2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b2<span class="token operator">:</span> Tuple2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aa'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>扩展：<code>infer</code>实现一个推导数组所有元素的类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 约束参数T为数组类型，
 * 判断T是否为数组，如果是数组类型则推导数组元素的类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FalttenArray<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">P</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * type Eg1 = number | string;
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> FalttenArray<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<span class="token comment">/**
 * type Eg2 = 1 | 'asd';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> FalttenArray<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'asd'</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
</code></pre></div><p><strong>ReturnType 获取函数的返回值类型。</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc ReturnType的实现其实和Parameters的基本一样
 * 无非是使用infer R的位置不一样。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="constructorparameters"><a href="#constructorparameters" class="header-anchor">#</a> ConstructorParameters</h3> <p><code>ConstructorParameters</code>可以获取类的构造函数的参数类型，存在一个元组中。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现还是利用infer进行推导构造函数的参数类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">ConstructorParameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>


<span class="token comment">/**
 * @example
 * type Eg = string;
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">ErrorConstructor</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span><span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Error<span class="token punctuation">;</span>
  <span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Error<span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> prototype<span class="token operator">:</span> Error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> ConstructorParameters<span class="token operator">&lt;</span>ErrorConstructor<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg2 = [name: string, sex?: number];
 */</span>
<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> sex<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> ConstructorParameters<span class="token operator">&lt;</span><span class="token keyword">typeof</span> People<span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>首先约束参数<code>T</code>为拥有构造函数的类。注意这里有个<code>abstract</code>修饰符，等下会说明。</p></li> <li><p>实现时，判断<code>T</code>是满足约束的类时，利用<code>infer P</code>自动推导构造函数的参数类型，并最终返回该类型。</p></li></ul> <h4 id="那么疑问来了-为什么要对t要约束为abstract抽象类呢-看下面例子"><a href="#那么疑问来了-为什么要对t要约束为abstract抽象类呢-看下面例子" class="header-anchor">#</a> 那么疑问来了，为什么要对T要约束为abstract抽象类呢？看下面例子：</h4> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 定义一个普通类
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">/**
 * 定义一个抽象类
 */</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MyAbstractClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c1<span class="token operator">:</span> <span class="token keyword">typeof</span> MyClass <span class="token operator">=</span> MyClass
<span class="token comment">// 报错，无法将抽象构造函数类型分配给非抽象构造函数类型</span>
<span class="token keyword">const</span> c2<span class="token operator">:</span> <span class="token keyword">typeof</span> MyClass <span class="token operator">=</span> MyAbstractClass

<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c3<span class="token operator">:</span> <span class="token keyword">typeof</span> MyAbstractClass <span class="token operator">=</span> MyClass
<span class="token comment">// 可以赋值</span>
<span class="token keyword">const</span> c4<span class="token operator">:</span> <span class="token keyword">typeof</span> MyAbstractClass <span class="token operator">=</span> MyAbstractClass
</code></pre></div><p>由此看出，如果将类型定义为抽象类（抽象构造函数），则既可以赋值为抽象类，也可以赋值为普通类；而反之则不行。</p> <p>这里继续提问，直接使用类作为类型，和使用<code>typeof 类</code>作为类型，有什么区别呢？</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 定义一个类
 */</span>
<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// p1可以正常赋值</span>
<span class="token keyword">const</span> p1<span class="token operator">:</span> People <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等号后面的People报错，类型“typeof People”缺少类型“People”中的以下属性: name, age</span>
<span class="token keyword">const</span> p2<span class="token operator">:</span> People <span class="token operator">=</span> People<span class="token punctuation">;</span>

<span class="token comment">// p3报错，类型 &quot;People&quot; 中缺少属性 &quot;prototype&quot;，但类型 &quot;typeof People&quot; 中需要该属性</span>
<span class="token keyword">const</span> p3<span class="token operator">:</span> <span class="token keyword">typeof</span> People <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// p4可以正常赋值</span>
<span class="token keyword">const</span> p4<span class="token operator">:</span> <span class="token keyword">typeof</span> People <span class="token operator">=</span> People<span class="token punctuation">;</span>
</code></pre></div><p><strong>结论是这样的：</strong></p> <ul><li><p>当把<code>类</code>直接作为<code>类型</code>时，该类型约束的是该类型必须是<code>类的实例</code>；即该类型获取的是该类上的<code>实例属性</code>和<code>实例方法</code>（也叫<code>原型方法</code>）；</p></li> <li><p>当把<code>typeof 类</code>作为类型时，约束的满足该类的类型；即该<code>类型</code>获取的是该类上的<code>静态属性和方法</code>。</p></li> <li><p>最后，只需要对<code>infer</code>的使用换个位置，便可以获取构造函数返回值的类型：</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">InstanceType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">abstract</span></span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="ts-compiler内部实现的类型"><a href="#ts-compiler内部实现的类型" class="header-anchor">#</a> Ts compiler内部实现的类型</h3> <ul><li>Uppercase</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc 构造一个将字符串转大写的类型
 * @example
 * type Eg1 = 'ABCD';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Uppercase<span class="token operator">&lt;</span><span class="token string">'abcd'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Lowercase</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc 构造一个将字符串转小大写的类型
 * @example
 * type Eg2 = 'abcd';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Lowercase<span class="token operator">&lt;</span><span class="token string">'ABCD'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Capitalize</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc 构造一个将字符串首字符转大写的类型
 * @example
 * type Eg3 = 'abcd';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Capitalize<span class="token operator">&lt;</span><span class="token string">'Abcd'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Uncapitalize</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc 构造一个将字符串首字符转小写的类型
 * @example
 * type Eg3 = 'ABCD';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Uncapitalize<span class="token operator">&lt;</span><span class="token string">'aBCD'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>这些类型工具，在<code>lib.es5.d.ts</code>文件中是看不到具体定义的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Uppercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Lowercase<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Capitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Uncapitalize<span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> intrinsic<span class="token punctuation">;</span>
</code></pre></div><h2 id="第三部分-自定义ts高级类型工具及类型编程技巧"><a href="#第三部分-自定义ts高级类型工具及类型编程技巧" class="header-anchor">#</a> 第三部分 自定义Ts高级类型工具及类型编程技巧</h2> <h3 id="symmetricdifference"><a href="#symmetricdifference" class="header-anchor">#</a> SymmetricDifference</h3> <p><code>SymmetricDifference&lt;T, U&gt;</code>获取没有同时存在于T和U内的类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">SymmetricDifference<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> SetDifference<span class="token operator">&lt;</span><span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * SetDifference的实现和Exclude一样
 */</span>
<span class="token keyword">type</span> <span class="token class-name">SymmetricDifference<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg = '1' | '4';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> SymmetricDifference<span class="token operator">&lt;</span><span class="token string">'1'</span> <span class="token operator">|</span> <span class="token string">'2'</span> <span class="token operator">|</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'2'</span> <span class="token operator">|</span> <span class="token string">'3'</span> <span class="token operator">|</span> <span class="token string">'4'</span><span class="token operator">&gt;</span>
</code></pre></div><p>其核心实现利用了3点：分发式联合类型、交叉类型和Exclude。</p> <ul><li><p>首先利用<code>Exclude</code>从获取存在于第一个参数但是不存在于第二个参数的类型</p></li> <li><p><code>Exclude</code>第2个参数是<code>T &amp; U</code>获取的是所有类型的交叉类型</p></li> <li><p><code>Exclude</code>第一个参数则是<code>T | U</code>，这是利用在联合类型在<code>extends</code>中的分发特性，可以理解为<code>Exclude&lt;T, T &amp; U&gt; | Exclude&lt;U, T &amp; U&gt;</code>;</p></li></ul> <p>总结一下就是，提取存在于<code>T</code>但不存在于<code>T &amp; U</code>的类型，然后再提取存在于<code>U</code>但不存在于<code>T &amp; U</code>的，最后进行联合。</p> <h3 id="functionkeys"><a href="#functionkeys" class="header-anchor">#</a> FunctionKeys</h3> <p>获取<code>T</code>中所有类型为函数的<code>key</code>组成的联合类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * @desc NonUndefined判断T是否为undefined
 */</span>
<span class="token keyword">type</span> <span class="token class-name">NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @desc 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg = 'key2' | 'key3';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">AType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
    <span class="token function-variable function">key2</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
    key3<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> FunctionKeys<span class="token operator">&lt;</span>AType<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>首先约束参数<code>T</code>类型为<code>object</code></p></li> <li><p>通过映射类型<code>K in keyof T</code>遍历所有的key，先通过<code>NonUndefined&lt;T[K]&gt;</code>过滤<code>T[K]</code>为<code>undefined | null</code>的类型，不符合的返回<code>never</code></p></li> <li><p>若<code>T[K]</code>为有效类型，则判断是否为<code>Function</code>类型，是的话返回<code>K</code>,否则<code>never</code>；此时可以得到的类型，例如：</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 上述的Eg在此时应该是如下类型，伪代码：
 */</span>
<span class="token keyword">type</span> <span class="token class-name">TempType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    key1<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">,</span>
    key2<span class="token operator">:</span> <span class="token string">'key2'</span><span class="token punctuation">,</span>
    key3<span class="token operator">:</span> <span class="token string">'key3'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>最后经过<code>{省略}[keyof T]</code>索引访问，取到的为值类型的联合类型<code>never | key2 | key3</code>,计算后就是<code>key2 | key3</code>;</li></ul> <p><strong>注意 1</strong></p> <ul><li><p><code>T[]</code>是索引访问操作，可以取到值的类型</p></li> <li><p><code>T['a' | 'b']</code>若<code>[]</code>内参数是联合类型，则也是分发索引的特性，依次取到值的类型进行联合</p></li> <li><p><code>T[keyof T]</code>则是获取<code>T</code>所有值的类型类型；</p></li> <li><p><code>never</code>和其他类型进行联合时，<code>never</code>是不存在的。例如：<code>never | number | string</code>等同于<code>number | string</code></p></li></ul> <p><strong>注意 2</strong></p> <ul><li><p><code>null</code>和<code>undefined</code>可以赋值给其他类型（开始该类型的严格赋值检测除外）,所以上述实现中需要使用<code>NonUndefined</code>先行判断。</p></li> <li><p><code>NonUndefined</code>中的实现，只判断了<code>T extends undefined</code>，其实也是因为两者可以互相兼容的。所以你换成<code>T extends null</code>或者<code>T extends null | undefined</code>都是可以的。</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// A = 1</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// B = 1</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">undefined</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>最后，如果你想写一个获取非函数类型的key组成的联合类型，无非就是<code>K</code>和<code>never</code>的位置不一样罢了。同样，你也可以实现<code>StringKeys</code>、<code>NumberKeys</code>等等。但是记得可以抽象个工厂类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Primitive</span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token builtin">string</span>
  <span class="token operator">|</span> <span class="token builtin">number</span>
  <span class="token operator">|</span> bigint
  <span class="token operator">|</span> <span class="token builtin">boolean</span>
  <span class="token operator">|</span> <span class="token builtin">symbol</span>
  <span class="token operator">|</span> <span class="token keyword">null</span>
  <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @desc 用于创建获取指定类型工具的类型工厂
 * @param T 待提取的类型
 * @param P 要创建的类型
 * @param IsCheckNon 是否要进行null和undefined检查
 */</span>
<span class="token keyword">type</span> <span class="token class-name">KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">P</span> <span class="token keyword">extends</span> Primitive <span class="token operator">|</span> <span class="token builtin">Function</span> <span class="token operator">|</span> object<span class="token punctuation">,</span> IsCheckNon <span class="token keyword">extends</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> IsCheckNon <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span>
    <span class="token operator">?</span> <span class="token punctuation">(</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">P</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">P</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * 例如上述KeysFactory就可以通过工厂类型进行创建了
 */</span>
<span class="token keyword">type</span> <span class="token class-name">FunctionKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">StringKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">NumberKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> KeysFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="mutablekeys"><a href="#mutablekeys" class="header-anchor">#</a> MutableKeys</h3> <p><code>MutableKeys&lt;T&gt;</code>查找<code>T</code>所有可选类型的<code>key</code>组成的联合类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">MutableKeys<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> IfEquals<span class="token operator">&lt;</span>
    <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">Q</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">P</span>
  <span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @desc 一个辅助类型，判断X和Y是否类型相同，
 * @returns 是则返回A，否则返回B
 */</span>
<span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token operator">?</span> <span class="token constant">A</span>
  <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>
</code></pre></div><p><code>MutableKeys</code>还是有一定难度的，讲解<code>MutableKeys</code>的实现，我们要分下面几个步骤：</p> <h4 id="第一步-先理解只读和非只读的一些特性"><a href="#第一步-先理解只读和非只读的一些特性" class="header-anchor">#</a> 第一步，先理解只读和非只读的一些特性</h4> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 遍历类型T，原封不动的返回，有点类似于拷贝类型的意思
 */</span>
<span class="token keyword">type</span> <span class="token class-name">RType1<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 遍历类型T，将每个key变成非只读
 * 或者理解成去掉只读属性更好理解。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">RType2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">-</span><span class="token keyword">readonly</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// R0 = { a: string; readonly b: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R0</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>

<span class="token comment">// R1 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R1</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// R2 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R2</span></span> <span class="token operator">=</span> RType2<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// R3 = { readonly a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R3</span></span> <span class="token operator">=</span> RType1<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// R4 = { a: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">R4</span></span> <span class="token operator">=</span> RType2<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">readonly</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到：<code>RType1</code>和<code>RType2</code>的参数为<strong>非只读</strong>的属性时，<code>R1</code>和<code>R2</code>的结果是一样的；<code>RType1</code>和<code>RType2</code>的参数为<strong>只读</strong>的属性时，得到的结果<code>R3</code>是<strong>只读</strong>的，<code>R4</code>是<strong>非只读</strong>的。所以，这里要敲个重点了：</p> <ul><li><p><code>[P in Keyof T]</code>是映射类型，而映射是同态的，同态即会拷贝原有的属性修饰符等。可以参考R0的例子。</p></li> <li><p>映射类型上的<code>-readonly</code>表示为<strong>非只读</strong>，或者可以理解为去掉<strong>只读</strong>。对于<strong>只读</strong>属性加上<code>-readonly</code>变成了<strong>非只读</strong>，而对<code>非只读</code>属性加上<code>-readonly</code>后还是<strong>非只读</strong>。一种常见的使用方式，比如你想把属性变成都是非只读的，不能前面不加修饰符（虽然不写就表示非只读），但是要考虑到同态拷贝的问题。</p></li></ul> <h4 id="第二步-解析ifequals"><a href="#第二步-解析ifequals" class="header-anchor">#</a> 第二步，解析IfEquals</h4> <p><code>IfEquals</code>用于判断类型<code>X</code>和<code>Y</code>是否相同，相等则返回<code>A</code>，否则返回<code>B</code>。这个函数是比较难的，也别怕啦，下面讲完就妥妥的明白啦~</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token builtin">never</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">extends</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>首先<code>IfEquals&lt;X, Y, A, B&gt;</code>的四个参数，<code>X和Y</code>是待比较的两个类型，如果相等则返回<code>A</code>，不相等返回<code>B</code>。</p></li> <li><p><code>IfEquals</code>的基本骨架是<code>type IfEquals&lt;&gt; = (参数1) extends (参数2) ? A : B</code>这样的，就是判断如果参数1的类型能够分配给参数2的类型，则返回<code>A</code>，否则返回<code>B</code>;</p></li> <li><p>参数1和参数2的基本结构是一样的，唯一区别在于X和Y不同。这里看下具体下面的例子：</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// A = &lt;T&gt;() =&gt; T extends string ? 1 : 2;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// B = &lt;T&gt;() =&gt; T extends number ? 1 : 2;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// C = 2</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>是不是很奇怪，为什么能推导出<code>A</code>和<code>B</code>类型是不一样的？告诉你答案：</p> <ul><li><p>这是利用了Ts编译器的一个特点，就是Ts编译器会认为如果两个类型（比如这里的<code>X</code>和<code>Y</code>）仅被用于约束两个相同的泛型函数则是相同的。这理解起来有些不可思议，或者说在逻辑上这种逻辑并不对（因为可以举出反例），但是Ts开发团队保证了这一特性今后不会变。</p></li> <li><p>注意，这里也会判断的属性修饰符，例如<code>readonly</code>, <code>可选属性</code>等，看通过下面的例子验证：</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * T2比T1多了readonly修饰符
 * T3比T1多了可选修饰符
 * 这里控制单一变量进行验证
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">readonly</span> key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// A1 = false</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T2</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// A2 = false</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T3</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>IfEquals</code>最后就是借助1和2来辅助判断（语法层面的），还有就是给<code>A</code>的默认值为<code>X</code>，<code>B</code>的默认值为<code>never</code>。</li></ul> <p><strong>关键问题</strong></p> <blockquote><p>判断类型是否相等（兼容）为什么不直接使用<code>type IfEquals&lt;X, Y, A, B&gt; = X extends Y ? A : B</code></p></blockquote> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">IfEquals<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">X</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 还用上面的例子
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">readonly</span> key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// A1 = true</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A1</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T2</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// A2 = true</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A2</span></span> <span class="token operator">=</span> IfEquals<span class="token operator">&lt;</span><span class="token constant">T1</span><span class="token punctuation">,</span> <span class="token constant">T3</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="第3步-解析mutablekeys实现逻辑"><a href="#第3步-解析mutablekeys实现逻辑" class="header-anchor">#</a> 第3步，解析MutableKeys实现逻辑</h4> <ul><li><p><code>MutableKeys</code>首先约束<code>T</code>为<code>object</code>类型</p></li> <li><p>通过映射类型<code>[P in keyof T]</code>进行遍历，key对应的值则是<code>IfEquals&lt;类型1, 类型2, P&gt;</code>，如果类型1和类型2相等则返回对应的<code>P</code>（也就是<code>key</code>），否则返回<code>never</code>。</p></li></ul> <p>而<code>P</code>其实就是一个只有一个当前key的联合类型，所以<code>[Q in P]: T[P]</code>也只是一个普通的映射类型。但是要注意的是参数1<code>{ [Q in P]: T[P] }</code>是通过<code>{}</code>构造的一个类型，参数2<code>{ -readonly [Q in P]: T[P] }</code>也是通过<code>{}</code>构造的一个类型,两者的唯一区别即使<code>-readonly</code>。</p> <p>所以这里就有意思了，回想一下上面的第一步的例子，是不是就理解了：如果<code>P</code>是只读的，那么参数1和参数2的<code>P</code>最终都是只读的；如果<code>P</code>是非只读的，则参数1的<code>P</code>为非只读的，而参数2的<code>P</code>被<code>-readonly</code>去掉了非只读属性从而变成了只读属性。因此就完成了筛选：<code>P</code>为非只读时<code>IfEquals</code>返回的<code>P</code>，<code>P</code>为只读时<code>IfEquals</code>返回<code>never</code>。</p> <ul><li>所以<code>key</code>为非只读时，类型为<code>key</code>，否则类型为<code>never</code>，最后通过<code>[keyof T]</code>得到了所有<code>非只读key</code>的联合类型。</li></ul> <h3 id="optionalkeys"><a href="#optionalkeys" class="header-anchor">#</a> OptionalKeys</h3> <p><code>OptionalKeys&lt;T&gt;</code>提取T中所有可选类型的key组成的联合类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">OptionalKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">P</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> OptionalKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>核心实现，用映射类型遍历所有key，通过<code>Pick&lt;T, P&gt;</code>提取当前<code>key</code>和<code>类型</code>。注意，这里也是利用了<code>同态拷贝会拷贝可选修饰符的特性</code>。</p></li> <li><p>利用<code>{} extends {当前key: 类型}</code>判断是否是可选类型。</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// Eg2 = false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">// Eg3 = true</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>key1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><p>利用的就是<code>{}</code>和只包含可选参数类型<code>{key?: string}</code>是兼容的这一特性。把<code>extends</code>前面的<code>{}</code>替换成<code>object</code>也是可以的。</p> <h3 id="增强pick"><a href="#增强pick" class="header-anchor">#</a> 增强Pick</h3> <ul><li>PickByValue提取指定值的类型</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 辅助函数，用于获取T中类型不能never的key组成的联合类型</span>
<span class="token keyword">type</span> <span class="token class-name">TypeKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PickByValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  TypeKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">V</span></span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 *  type Eg = {
 *    key1: number;
 *    key3: number;
 *  }
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> PickByValue<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> key3<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>Ts的类型兼容特性，所以类似<code>string</code>是可以分配给<code>string | number</code>的，因此上述并不是精准的提取方式。如果实现精准的方式，则可以考虑下面个这个类型工具。</p> <ul><li>PickByValueExact精准的提取指定值的类型</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">PickByValueExact<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  TypeKeys<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">V</span><span class="token punctuation">]</span>
    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">V</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>

<span class="token comment">// type Eg1 = { b: number };</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> PickByValueExact<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// type Eg2 = { b: number; c: number | undefined }</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> PickByValueExact<span class="token operator">&lt;</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
</code></pre></div><p><code>PickByValueExact</code>的核心实现主要有三点：</p> <p>一是利用<code>Pick</code>提取我们需要的<code>key</code>对应的类型</p> <p>二是利用给泛型套一层元组规避<code>extends</code>的<strong>分发式联合类型</strong>的特性</p> <p>三是利用两个类型互相兼容的方式判断是否相同。</p> <p>具体可以看下下面例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Eq1<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">X</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eq2<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Eq3<span class="token operator">&lt;</span><span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">X</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// boolean, 期望是false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Eq1<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>
<span class="token comment">// false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg2</span> <span class="token operator">=</span> Eq2<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>

<span class="token comment">// true，期望是false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg3</span> <span class="token operator">=</span> Eq2<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// false</span>
<span class="token keyword">type</span> <span class="token class-name">Eg4</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>

<span class="token comment">// true，非strictNullChecks模式下的结果</span>
<span class="token keyword">type</span> <span class="token class-name">Eg5</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
<span class="token comment">// false，strictNullChecks模式下的结果</span>
<span class="token keyword">type</span> <span class="token class-name">Eg6</span> <span class="token operator">=</span> Eq3<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>从<code>Eg1</code>和<code>Eg2</code>对比可以看出，给<code>extends</code>参数套上元组可以避免分发的特性，从而得到期望的结果；</p></li> <li><p>从<code>Eg3</code>和<code>Eg4</code>对比可以看出，通过判断两个类型互相是否兼容的方式，可以得到从属类型的正确相等判断。</p></li> <li><p>从<code>Eg5</code>和<code>Eg6</code>对比可以看出，非<code>strictNullChecks</code>模式下，<code>undefined</code>和<code>null</code>可以赋值给其他类型的特性，导致<code>number | undefined</code>, <code>number</code>是兼容的，因为是非<code>strictNullChecks</code>模式，所以有这个结果也是符合预期。如果不需要此兼容结果，完全可以开启<code>strictNullChecks</code>模式。</p></li></ul> <p>最后，同理想得到<code>OmitByValue</code>和<code>OmitByValueExact</code>基本一样的思路就不多说了，大家可以自己思考实现。</p> <h3 id="intersection"><a href="#intersection" class="header-anchor">#</a> Intersection</h3> <p><code>Intersection&lt;T, U&gt;</code>从<code>T</code>中提取存在于<code>U</code>中的<code>key</code>和对应的类型。（注意，最终是从<code>T</code>中提取<code>key</code>和类型）</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * 核心思路利用Pick提取指定的key组成的类型
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span>
  Extract<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Extract<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>

<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Intersection<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span> key2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>约束<code>T</code>和<code>U</code>都是<code>object</code>，然后利用<code>Pick</code>提取指定的<code>key</code>组成的类型</p></li> <li><p>通过<code>Extract&lt;keyof T, keyof U&gt;</code>提取同时存在于<code>T</code>和<code>U</code>中的<code>key</code>，<code>Extract&lt;keyof U, keyof T&gt;</code>也是同样的操作</p></li></ul> <p>那么为什么要做<strong>2</strong>次<code>Extract</code>然后再交叉类型呢？原因还是在于处理类型的兼容推导问题，还记得<code>string</code>可分配给<code>string | number</code>的兼容吧。</p> <p><strong>扩展：</strong></p> <p>定义<code>Diff&lt;T, U&gt;</code>，从<code>T</code>中排除存在于<code>U</code>中的key和类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Diff<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>
  <span class="token constant">T</span><span class="token punctuation">,</span>
  Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">U</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="overwrite-和-assign"><a href="#overwrite-和-assign" class="header-anchor">#</a> Overwrite 和 Assign</h3> <p><code>Overwrite&lt;T, U&gt;</code>从<code>U</code>中的同名属性的类型覆盖<code>T</code>中的同名属性类型。(后者中的同名属性覆盖前者)</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * Overwrite实现
 * 获取前者独有的key和类型，再取两者共有的key和该key在后者中的类型，最后合并。
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Overwrite<span class="token operator">&lt;</span>
  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">I</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Intersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">I</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg1 = { key1: number; }
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg1</span> <span class="token operator">=</span> Overwrite<span class="token operator">&lt;</span><span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>key1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> other<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p>首先约束<code>T</code>和<code>U</code>这两个参数都是<code>object</code></p></li> <li><p>借助一个参数<code>I</code>的默认值作为实现过程，使用的时候不需要传递I参数（只是辅助实现的）</p></li> <li><p>通过<code>Diff&lt;T, U&gt;</code>获取到存在于<code>T</code>但是不存在于<code>U</code>中的key和其类型。（即获取<code>T</code>自己特有<code>key</code>和类型）。</p></li> <li><p>通过<code>Intersection&lt;U, T&gt;</code>获取<code>U</code>和<code>T</code>共有的<code>key</code>已经该key在<code>U</code>中的类型。即获取后者同名<code>key</code>已经类型。</p></li> <li><p>最后通过交叉类型进行合并，从而曲线救国实现了覆盖操作。</p></li></ul> <p>扩展：如何实现一个<code>Assign&lt;T, U&gt;</code>（类似于<code>Object.assign()</code>）用于合并呢？</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 实现</span>
<span class="token keyword">type</span> <span class="token class-name">Assign<span class="token operator">&lt;</span>
  <span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span>
  <span class="token constant">I</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Intersection<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> Diff<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">I</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @example
 * type Eg = {
 *   name: string;
 *   age: string;
 *   other: string;
 * }
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> Assign<span class="token operator">&lt;</span>
  <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> age<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> other<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>想一下，是不是就是先找到前者独有的<code>key</code>和<code>类型</code>，再找到两者共有的key以及该<code>key</code>在后者中的<code>类型</code>，最后找到后者独有的<code>key</code>和<code>类型</code>，最后依次的合并进去。</p> <h3 id="deeprequired"><a href="#deeprequired" class="header-anchor">#</a> DeepRequired</h3> <p><code>DeepRequired&lt;T&gt;</code>将<code>T</code>的转换成必须属性。如果<code>T</code>为对象，则将递归对象将所有<code>key</code>转换成<code>required</code>，类型转换为<code>NonUndefined</code>；如果<code>T</code>为数组则递归遍历数组将每一项设置为<code>NonUndefined</code>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * DeepRequired实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">DeepRequired<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
  <span class="token operator">?</span> <span class="token constant">T</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span></span>
    <span class="token operator">?</span> _DeepRequiredArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
    <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>
      <span class="token operator">?</span> _DeepRequiredObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
      <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">// 辅助工具，递归遍历数组将每一项转换成必选</span>
<span class="token keyword">interface</span> <span class="token class-name">_DeepRequiredArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span>DeepRequired<span class="token operator">&lt;</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 辅助工具，递归遍历对象将每一项转换成必选</span>
<span class="token keyword">type</span> <span class="token class-name">_DeepRequiredObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> DeepRequired<span class="token operator">&lt;</span>NonUndefined<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><code>DeepRequired</code>利用<code>extends</code>判断如果是函数或<code>Primitive</code>的类型，就直接返回该类型。</p></li> <li><p>如果是数组类型，则借助<code>_DeepRequiredArray</code>进行递归，并且传递的参数为数组所有子项类型组成的联合类型，如下：</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span>
<span class="token comment">/**
 * @description 对数组进行number索引访问，
 * 得到的是所有子项类型组成的联合类型
 * type B = string | number
 */</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span>
</code></pre></div><ul><li><p><code>_DeepRequiredObject</code>是个接口（定义成type也可以），其类型是<code>Array&lt;T&gt;</code>；而此处的<code>T</code>则通过<code>DeepRequired&lt;T&gt;</code>进行对每一项进行递归；在<code>T</code>被使用之前，先被<code>NonUndefined&lt;T&gt;</code>处理一次，去掉无效类型。</p></li> <li><p>如果是对象类型，则借助<code>_DeepRequiredObject</code>实现对象的递归遍历。<code>_DeepRequiredObject</code>只是一个普通的映射类型进行变量，然后对每个key添加<code>-?</code>修饰符转换成<code>required</code>类型。</p></li></ul> <h3 id="deepreadonlyarray"><a href="#deepreadonlyarray" class="header-anchor">#</a> DeepReadonlyArray</h3> <p><code>DeepReadonlyArray&lt;T&gt;</code>将<code>T</code>的转换成只读的，如果<code>T</code>为<code>object</code>则将所有的<code>key</code>转换为只读的，如果<code>T</code>为数组则将数组转换成只读数组。整个过程是深度递归的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * DeepReadonly实现
 */</span>
<span class="token keyword">type</span> <span class="token class-name">DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">|</span> Primitive
  <span class="token operator">?</span> <span class="token constant">T</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">_DeepReadonlyArray<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> _DeepReadonlyArray<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">_DeepReadonlyObject<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> _DeepReadonlyObject<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">&gt;</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 工具类型，构造一个只读数组
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">_DeepReadonlyArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReadonlyArray<span class="token operator">&lt;</span>DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">/**
 * 工具类型，构造一个只读对象
 */</span>
<span class="token keyword">type</span> <span class="token class-name">_DeepReadonlyObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>基本实现原理和<code>DeepRequired</code>一样，但是注意<code>infer U</code>自动推导数组的类型，<code>infer V</code>推导对象的类型。</li></ul> <h3 id="uniontointersection"><a href="#uniontointersection" class="header-anchor">#</a> UnionToIntersection</h3> <p>将联合类型转变成交叉类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">UnionToIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span>
  <span class="token operator">?</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token keyword">type</span> <span class="token class-name">Eg</span> <span class="token operator">=</span> UnionToIntersection<span class="token operator">&lt;</span><span class="token punctuation">{</span> key1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span> key2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><p><code>T extends any ? (arg: T) =&gt; void : never</code>该表达式一定走true分支，用此方式构造一个逆变的联合类型<code>(arg: T1) =&gt; void | (arg: T2) =&gt; void | (arg: Tn) =&gt; void</code></p></li> <li><p>再利用第二个<code>extends</code>配合<code>infer</code>推导得到U的类型，但是利用<code>infer</code>对<strong>协变类型的特性得到交叉类型</strong>。</p></li></ul></div> <!----> <div class="content__content-bottom"></div> <footer class="page-meta"><div class="edit-link"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon edit-icon"><path d="M117.953 696.992 64.306 959.696l265.931-49.336 450.204-452.505-212.284-213.376-450.204 452.513zm496.384-296.326L219.039 797.993l-46.108-46.34L568.233 354.33l46.104 46.335zm345.357-122.99-114.45 115.04-212.288-213.377 114.45-115.035 212.288 213.371zm0 0" fill="currentColor"></path></svg> <a href="https://github.com/sykinggg/notes/edit/main/docs/ts/project/inDepthTs.md" target="_blank" rel="noopener noreferrer">Edit this page</a></div> <div class="meta-item update-time"><span class="label">Last update:</span> <span class="info">September 14, 2021 10:16</span></div> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/notes/ts/project/compilationContext/">
        编译上下文
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 0 1-18.616.092 15.368 15.368 0 0 1-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 0 1 5.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 0 1 5.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <!----> <!----> <div class="content__page-bottom"></div></main> <!----></div><div class="global-ui"><!----><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">This app can be installed on your PC or mobile device.  This will allow this web app to look and behave like any other installed app.  You will find it in your app lists and be able to pin it to your home screen, start menus or task bars.  This installed web app will also be able to safely interact with other apps and your operating system. </p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>Description</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        Install <span></span></button> <button class="cancel-button">
        Cancel
      </button></div></div></div></div><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close"></button> <button class="pswp__button pswp__button--share"></button> <button class="pswp__button pswp__button--fs"></button> <button class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left"></button> <button class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><div class="my-popup" style="display:none;" data-v-5f98aac3><div class="my-popup-container" data-v-5f98aac3><div class="my-popup-exit" data-v-5f98aac3></div> <img src="" alt data-v-5f98aac3></div></div></div></div>
    <script src="/notes/assets/js/app.e8b8d673.js" defer></script><script src="/notes/assets/js/vendors~layout-Layout.797b930b.js" defer></script><script src="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.fd95594f.js" defer></script><script src="/notes/assets/js/page-深入TypeScript.7d08d3f1.js" defer></script><script src="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.5018eb2c.js" defer></script>
  </body>
</html>
