# 第51题：es5 中的类和es6中的class

在`es5`中主要是通过构造函数方式和原型方式来定义一个类，在`es6`中我们可以通过`class`来定义类。

## 一、class类必须new调用，不能直接执行。

<!-- <img :src="$withBase('/assets/jsInterview/jsInterviewQuestion/1658468196558.jpg')" alt="demo"/> -->

![demo](/assets/jsInterview/jsInterviewQuestion/1658468196558.jpg)

`class`类执行的话会报错，而es5中的类和普通函数并没有本质区别，执行肯定是ok的。

## 二、class类不存在变量提升

<!-- <img :src="$withBase('/assets/jsInterview/jsInterviewQuestion/1658468351155.jpg')" alt="demo"/> -->

![demo](/assets/jsInterview/jsInterviewQuestion/1658468351155.jpg)

<!-- <img :src="$withBase('/assets/jsInterview/jsInterviewQuestion/1658468420812.jpg')" alt="demo"/> -->

![demo](/assets/jsInterview/jsInterviewQuestion/1658468420812.jpg)

图2报错，说明class方式没有把类的定义提升到顶部。

## 三、class类无法遍历它实例原型链上的属性和方法

```js
function Foo (color) {
    this.color = color
}
Foo.prototype.like = function () {
    console.log(`like${this.color}`)
}
let foo = new Foo()

for (let key in foo) {
    // 原型上的like也被打印出来了
    console.log(key)  // color、like
}
```

```js
class Foo {
    constructor (color) {
        this.color = color
    }
    like () {
        console.log(`like${this.color}`)
    }
}
let foo = new Foo('red')

for (let key in foo) {
    // 只打印一个color,没有打印原型链上的like
    console.log(key)  // color
}
```

## 四、new.target属性

es6为`new`命令引入了一个`new.target`属性，它会返回`new`命令作用于的那个构造函数。如果不是通过`new`调用或`Reflect.construct()`调用的，`new.target`会返回`undefined`

```js
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

let obj = {}
Person.call(obj, 'red') // 此时使用非new的调用方式就会报错
```

## 五、class类有static静态方法

`static`静态方法只能通过类调用，不会出现在实例上；另外如果静态方法包含 `this` 关键字，这个 `this` 指的是类，而不是实例。`static`声明的静态属性和方法都可以被子类继承。

```js
class Foo {
  static bar() {
    this.baz(); // 此处的this指向类
  }
  static baz() {
    console.log('hello'); // 不会出现在实例中
  }
  baz() {
    console.log('world');
  }
}
```