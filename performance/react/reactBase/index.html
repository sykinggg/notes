<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 运行时优化方案 | 前端 学习</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <link rel="manifest" href="/notes/manifest.webmanifest" crossorigin="use-credentials">
    <meta name="description" content="君子藏器于身 待时而动 天下有道则见 无道则隐">
    <meta property="og:url" content="/notes/performance/react/reactBase.html">
    <meta property="og:site_name" content="前端 学习">
    <meta property="og:title" content="React 运行时优化方案">
    <meta property="og:description" content="React 运行时优化方案 几大 JS 框架的设计思路 首先，是 React，React 是一个重运行时的框架，在数据发生变化后，并没有直接去操作 dom，而是生成一个新的所谓的虚拟 dom，它可以帮助我们解决跨平台和兼容性问题，并且通过 diff 算法得出最小的操作行为，这些全部都是在运行时来做的。 最近很火的 Svelte ，就是一个典型的重编译的框架，">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en-US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="前端 学习">
    <meta property="article:author" content="sy">
    <meta name="theme-color" content="#46bd87">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    
    <link rel="preload" href="/notes/assets/css/0.styles.5a16df27.css" as="style"><link rel="preload" href="/notes/assets/js/app.36180562.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Layout.bad6b0ac.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.f2412bde.js" as="script"><link rel="preload" href="/notes/assets/js/page-React运行时优化方案.1815da7d.js" as="script"><link rel="preload" href="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.8a19680c.js" as="script"><link rel="prefetch" href="/notes/assets/js/645.8af7b421.js"><link rel="prefetch" href="/notes/assets/js/646.9cbbad1b.js"><link rel="prefetch" href="/notes/assets/js/647.5679ee0c.js"><link rel="prefetch" href="/notes/assets/js/layout-Blog.eb05d08e.js"><link rel="prefetch" href="/notes/assets/js/layout-Layout.a53d4054.js"><link rel="prefetch" href="/notes/assets/js/layout-NotFound.932ab794.js"><link rel="prefetch" href="/notes/assets/js/layout-Slide.716eb990.js"><link rel="prefetch" href="/notes/assets/js/page-$mount.79b65d62.js"><link rel="prefetch" href="/notes/assets/js/page--0036d571.2c479ddc.js"><link rel="prefetch" href="/notes/assets/js/page--022ad8a1.55a524ce.js"><link rel="prefetch" href="/notes/assets/js/page--049c9a9f.722a1d42.js"><link rel="prefetch" href="/notes/assets/js/page--050f4996.ff7c026f.js"><link rel="prefetch" href="/notes/assets/js/page--05ca34d9.0ea87582.js"><link rel="prefetch" href="/notes/assets/js/page--06138101.fb555010.js"><link rel="prefetch" href="/notes/assets/js/page--078553ea.5a9ac9c8.js"><link rel="prefetch" href="/notes/assets/js/page--07c5ad21.046234a3.js"><link rel="prefetch" href="/notes/assets/js/page--07f0b7af.fb3e9655.js"><link rel="prefetch" href="/notes/assets/js/page--08402fbe.1f0e575d.js"><link rel="prefetch" href="/notes/assets/js/page--0a137961.69c24388.js"><link rel="prefetch" href="/notes/assets/js/page--0b6292d3.3fb88369.js"><link rel="prefetch" href="/notes/assets/js/page--0b81571e.18165ff5.js"><link rel="prefetch" href="/notes/assets/js/page--0c7d4a27.eecf40eb.js"><link rel="prefetch" href="/notes/assets/js/page--0d936993.0cbda207.js"><link rel="prefetch" href="/notes/assets/js/page--0e573275.8756da8f.js"><link rel="prefetch" href="/notes/assets/js/page--0f2ef575.9ec9b881.js"><link rel="prefetch" href="/notes/assets/js/page--0fb13921.02521cc9.js"><link rel="prefetch" href="/notes/assets/js/page--0fe0372e.b9db1b7b.js"><link rel="prefetch" href="/notes/assets/js/page--10902ffe.10d69854.js"><link rel="prefetch" href="/notes/assets/js/page--12bc566b.c5775f29.js"><link rel="prefetch" href="/notes/assets/js/page--135834a1.6880ad01.js"><link rel="prefetch" href="/notes/assets/js/page--15961e72.c748747c.js"><link rel="prefetch" href="/notes/assets/js/page--17036b33.8ca26798.js"><link rel="prefetch" href="/notes/assets/js/page--172068b9.882df55e.js"><link rel="prefetch" href="/notes/assets/js/page--18126b85.12fb3413.js"><link rel="prefetch" href="/notes/assets/js/page--19a1b422.6a88783c.js"><link rel="prefetch" href="/notes/assets/js/page--1a00028a.7e93a79a.js"><link rel="prefetch" href="/notes/assets/js/page--1c6aa5c2.13a02616.js"><link rel="prefetch" href="/notes/assets/js/page--1fece121.34a6b8f5.js"><link rel="prefetch" href="/notes/assets/js/page--201cfbe1.e0649e0a.js"><link rel="prefetch" href="/notes/assets/js/page--2095282b.2114b91e.js"><link rel="prefetch" href="/notes/assets/js/page--21792c01.45b9398a.js"><link rel="prefetch" href="/notes/assets/js/page--226f1079.75a7e31c.js"><link rel="prefetch" href="/notes/assets/js/page--2518076e.a7f3a2a4.js"><link rel="prefetch" href="/notes/assets/js/page--25cb6e5f.a11d0705.js"><link rel="prefetch" href="/notes/assets/js/page--2616bc7e.3617b030.js"><link rel="prefetch" href="/notes/assets/js/page--27a556ad.f8c8101f.js"><link rel="prefetch" href="/notes/assets/js/page--27c21126.2e864756.js"><link rel="prefetch" href="/notes/assets/js/page--28435cbb.42ca783c.js"><link rel="prefetch" href="/notes/assets/js/page--28c148fe.6dd11541.js"><link rel="prefetch" href="/notes/assets/js/page--2ae50662.67a004ce.js"><link rel="prefetch" href="/notes/assets/js/page--2c665981.ef4b85eb.js"><link rel="prefetch" href="/notes/assets/js/page--2d021821.9db0a5d0.js"><link rel="prefetch" href="/notes/assets/js/page--31799879.fff28a94.js"><link rel="prefetch" href="/notes/assets/js/page--33b11326.b78e5e5c.js"><link rel="prefetch" href="/notes/assets/js/page--3477437b.7c9027a7.js"><link rel="prefetch" href="/notes/assets/js/page--34ad062f.1b0a4ffe.js"><link rel="prefetch" href="/notes/assets/js/page--357aec57.93e96994.js"><link rel="prefetch" href="/notes/assets/js/page--35f61a61.4a2711ed.js"><link rel="prefetch" href="/notes/assets/js/page--36897e27.6e1496ee.js"><link rel="prefetch" href="/notes/assets/js/page--36b30161.ac52745e.js"><link rel="prefetch" href="/notes/assets/js/page--377508c1.abb97a59.js"><link rel="prefetch" href="/notes/assets/js/page--3779bcfe.3f421261.js"><link rel="prefetch" href="/notes/assets/js/page--389d5da5.9567efe8.js"><link rel="prefetch" href="/notes/assets/js/page--38ef908f.92ab6792.js"><link rel="prefetch" href="/notes/assets/js/page--39c1a916.d4ec6819.js"><link rel="prefetch" href="/notes/assets/js/page--39e34c63.9e83802a.js"><link rel="prefetch" href="/notes/assets/js/page--3bbd34b1.c2cdc0e6.js"><link rel="prefetch" href="/notes/assets/js/page--3d00ca45.b2e62221.js"><link rel="prefetch" href="/notes/assets/js/page--3d121781.9ee3fddb.js"><link rel="prefetch" href="/notes/assets/js/page--3d5ab373.6490827f.js"><link rel="prefetch" href="/notes/assets/js/page--41d1702a.c090759e.js"><link rel="prefetch" href="/notes/assets/js/page--427db7c1.770087a2.js"><link rel="prefetch" href="/notes/assets/js/page--4365fcbe.75263b13.js"><link rel="prefetch" href="/notes/assets/js/page--466a516d.eefff075.js"><link rel="prefetch" href="/notes/assets/js/page--46f53541.7837d780.js"><link rel="prefetch" href="/notes/assets/js/page--4776c269.a06dbad5.js"><link rel="prefetch" href="/notes/assets/js/page--4803a967.9db63a04.js"><link rel="prefetch" href="/notes/assets/js/page--48c4e433.66312ec3.js"><link rel="prefetch" href="/notes/assets/js/page--48f9c9d9.0f710443.js"><link rel="prefetch" href="/notes/assets/js/page--4a252f57.e22d15bf.js"><link rel="prefetch" href="/notes/assets/js/page--4b35cd6a.288d7e17.js"><link rel="prefetch" href="/notes/assets/js/page--4bd2c839.c5d4802e.js"><link rel="prefetch" href="/notes/assets/js/page--4be1980d.c6794c38.js"><link rel="prefetch" href="/notes/assets/js/page--4c3dfc92.d80647d1.js"><link rel="prefetch" href="/notes/assets/js/page--4c9b9bf3.0876000f.js"><link rel="prefetch" href="/notes/assets/js/page--4caf2956.a0fd46d0.js"><link rel="prefetch" href="/notes/assets/js/page--4df59ba1.8d40d239.js"><link rel="prefetch" href="/notes/assets/js/page--4dfb2a67.fc9b72c2.js"><link rel="prefetch" href="/notes/assets/js/page--4e2425dd.4465162a.js"><link rel="prefetch" href="/notes/assets/js/page--4eb2620a.31235f06.js"><link rel="prefetch" href="/notes/assets/js/page--4fd512b5.983274f8.js"><link rel="prefetch" href="/notes/assets/js/page--4ff1cd2e.c383df52.js"><link rel="prefetch" href="/notes/assets/js/page--505dfb41.359736f8.js"><link rel="prefetch" href="/notes/assets/js/page--5293e923.27a5daa3.js"><link rel="prefetch" href="/notes/assets/js/page--5381ba01.df0bcdb6.js"><link rel="prefetch" href="/notes/assets/js/page--550b58e9.b21a077e.js"><link rel="prefetch" href="/notes/assets/js/page--564b24b3.2fd8178b.js"><link rel="prefetch" href="/notes/assets/js/page--598867f3.96abbce5.js"><link rel="prefetch" href="/notes/assets/js/page--5be0cf2e.3809e728.js"><link rel="prefetch" href="/notes/assets/js/page--5c1b876b.d5b11f84.js"><link rel="prefetch" href="/notes/assets/js/page--60c3812d.23c7836e.js"><link rel="prefetch" href="/notes/assets/js/page--6213086b.6c86cb32.js"><link rel="prefetch" href="/notes/assets/js/page--624c4841.b786b6a6.js"><link rel="prefetch" href="/notes/assets/js/page--6389398f.3c2b5700.js"><link rel="prefetch" href="/notes/assets/js/page--6497f0a1.cc5e5a51.js"><link rel="prefetch" href="/notes/assets/js/page--649d273e.9bab0aae.js"><link rel="prefetch" href="/notes/assets/js/page--663eaefe.d97a6dd6.js"><link rel="prefetch" href="/notes/assets/js/page--66f10201.5257daa6.js"><link rel="prefetch" href="/notes/assets/js/page--6877a3e2.7e0d3d51.js"><link rel="prefetch" href="/notes/assets/js/page--6afe7ce1.0d05ba9d.js"><link rel="prefetch" href="/notes/assets/js/page--6cbf38e1.d1530b60.js"><link rel="prefetch" href="/notes/assets/js/page--6ce92f3e.791d2811.js"><link rel="prefetch" href="/notes/assets/js/page--6e597d21.13545f6e.js"><link rel="prefetch" href="/notes/assets/js/page--6e740896.14457380.js"><link rel="prefetch" href="/notes/assets/js/page--6f049967.be54b523.js"><link rel="prefetch" href="/notes/assets/js/page--6ff33237.ad642aeb.js"><link rel="prefetch" href="/notes/assets/js/page--70f1ad1b.bd84ae09.js"><link rel="prefetch" href="/notes/assets/js/page--7458eaaa.ef308bed.js"><link rel="prefetch" href="/notes/assets/js/page--746db89a.6a0d71d1.js"><link rel="prefetch" href="/notes/assets/js/page--762ae66f.66b45ecb.js"><link rel="prefetch" href="/notes/assets/js/page--78218936.8fd65d7c.js"><link rel="prefetch" href="/notes/assets/js/page--7a6b8eb1.c7b04a1d.js"><link rel="prefetch" href="/notes/assets/js/page--7b0b14b7.99ca1369.js"><link rel="prefetch" href="/notes/assets/js/page--7b24903e.85f660a4.js"><link rel="prefetch" href="/notes/assets/js/page--7c0f4619.80a6fc61.js"><link rel="prefetch" href="/notes/assets/js/page--7c62eb01.4358ae9f.js"><link rel="prefetch" href="/notes/assets/js/page--7c8b8781.b9b447ec.js"><link rel="prefetch" href="/notes/assets/js/page--7d3b14f1.95b0dcd5.js"><link rel="prefetch" href="/notes/assets/js/page--7e94c3bb.71e1f972.js"><link rel="prefetch" href="/notes/assets/js/page--7fc7e4a1.8ffa0dc2.js"><link rel="prefetch" href="/notes/assets/js/page--82271b92.535af386.js"><link rel="prefetch" href="/notes/assets/js/page--828e159e.db3c71af.js"><link rel="prefetch" href="/notes/assets/js/page--8cd36aaa.c2956b93.js"><link rel="prefetch" href="/notes/assets/js/page--8e28d8be.03287c11.js"><link rel="prefetch" href="/notes/assets/js/page--9009daaa.b13c5aba.js"><link rel="prefetch" href="/notes/assets/js/page--9230e83a.c0354b2d.js"><link rel="prefetch" href="/notes/assets/js/page--9fdba57e.427406fd.js"><link rel="prefetch" href="/notes/assets/js/page--a051453e.eaaed1e0.js"><link rel="prefetch" href="/notes/assets/js/page--a1c4239e.d047e50d.js"><link rel="prefetch" href="/notes/assets/js/page--a8a8c1be.2aa56e0a.js"><link rel="prefetch" href="/notes/assets/js/page--aabdd1a6.a3ee4544.js"><link rel="prefetch" href="/notes/assets/js/page--b0ec1952.1e84895a.js"><link rel="prefetch" href="/notes/assets/js/page--b5901aa6.da378df0.js"><link rel="prefetch" href="/notes/assets/js/page--c185ca2a.de88463d.js"><link rel="prefetch" href="/notes/assets/js/page--c4cd30aa.20adbbb9.js"><link rel="prefetch" href="/notes/assets/js/page--cba59586.e3552a53.js"><link rel="prefetch" href="/notes/assets/js/page--cc19dc5e.8ed1f9cc.js"><link rel="prefetch" href="/notes/assets/js/page--cf39bd12.91612cbd.js"><link rel="prefetch" href="/notes/assets/js/page--d0d30f3e.93f5fd88.js"><link rel="prefetch" href="/notes/assets/js/page--d206ab7e.e74fb9ec.js"><link rel="prefetch" href="/notes/assets/js/page--d2ed8dae.27f2906a.js"><link rel="prefetch" href="/notes/assets/js/page--d676831e.b2a2fb73.js"><link rel="prefetch" href="/notes/assets/js/page--d6d819fe.4192b8e8.js"><link rel="prefetch" href="/notes/assets/js/page--d994fd7e.6efb46c5.js"><link rel="prefetch" href="/notes/assets/js/page--dd5a1a16.c427a2cf.js"><link rel="prefetch" href="/notes/assets/js/page--df9ce13a.17fc80e0.js"><link rel="prefetch" href="/notes/assets/js/page--e0b57efe.6b117b35.js"><link rel="prefetch" href="/notes/assets/js/page--eb673c12.cc2fc051.js"><link rel="prefetch" href="/notes/assets/js/page--ebf2773e.90f1dff0.js"><link rel="prefetch" href="/notes/assets/js/page--ef64acb6.777e6709.js"><link rel="prefetch" href="/notes/assets/js/page--f77f473e.3334cfce.js"><link rel="prefetch" href="/notes/assets/js/page--fb1d49b6.adf7a235.js"><link rel="prefetch" href="/notes/assets/js/page-1、说说你对SPA单页面的理解，它的优缺点分别是什么？.1664cc2c.js"><link rel="prefetch" href="/notes/assets/js/page-24个JavaScript循环遍历方法.b4274e9e.js"><link rel="prefetch" href="/notes/assets/js/page-44个Javascript变态题解析.4463b95e.js"><link rel="prefetch" href="/notes/assets/js/page-49个CSS知识点.de186f91.js"><link rel="prefetch" href="/notes/assets/js/page-@charset.b8d73b46.js"><link rel="prefetch" href="/notes/assets/js/page-@types.6f6998da.js"><link rel="prefetch" href="/notes/assets/js/page-@umijsplugin-dva.62bdeb4e.js"><link rel="prefetch" href="/notes/assets/js/page-@umijsplugin-qiankun.8b365b33.js"><link rel="prefetch" href="/notes/assets/js/page-AMD模块.f1fd8f7c.js"><link rel="prefetch" href="/notes/assets/js/page-API.ffdae059.js"><link rel="prefetch" href="/notes/assets/js/page-Arrayprototypeflat().ecc49090.js"><link rel="prefetch" href="/notes/assets/js/page-Barrel.cf2685cf.js"><link rel="prefetch" href="/notes/assets/js/page-Bind是有害的.4b35cbb9.js"><link rel="prefetch" href="/notes/assets/js/page-CSSGrid网格布局教程.dbaed4c4.js"><link rel="prefetch" href="/notes/assets/js/page-CSS选择符.9c16512d.js"><link rel="prefetch" href="/notes/assets/js/page-Canvas和SVG区别.9ed7aec4.js"><link rel="prefetch" href="/notes/assets/js/page-CommonJS.9ba78b97.js"><link rel="prefetch" href="/notes/assets/js/page-Configuration.9ec98d5f.js"><link rel="prefetch" href="/notes/assets/js/page-Consumer向上找不到Provider的时候怎么办.f36fe43e.js"><link rel="prefetch" href="/notes/assets/js/page-ContentTypes.bcb15007.js"><link rel="prefetch" href="/notes/assets/js/page-Css单位.234e4f90.js"><link rel="prefetch" href="/notes/assets/js/page-Decorators.2f22b151.js"><link rel="prefetch" href="/notes/assets/js/page-Diff算法.8d2a1a71.js"><link rel="prefetch" href="/notes/assets/js/page-ES10新特性（2019）.84848bfb.js"><link rel="prefetch" href="/notes/assets/js/page-ES6新特性（2015）.91795a9a.js"><link rel="prefetch" href="/notes/assets/js/page-ES7新特性（2016）.78fec664.js"><link rel="prefetch" href="/notes/assets/js/page-ES8新特性（2017）.910b5e36.js"><link rel="prefetch" href="/notes/assets/js/page-ES9新特性（2018）.ba036087.js"><link rel="prefetch" href="/notes/assets/js/page-FetchAPI教程.50f003ab.js"><link rel="prefetch" href="/notes/assets/js/page-FileReader.d4cea071.js"><link rel="prefetch" href="/notes/assets/js/page-Flex布局教程：实例篇.6364defb.js"><link rel="prefetch" href="/notes/assets/js/page-Flex布局教程：语法篇.73497b90.js"><link rel="prefetch" href="/notes/assets/js/page-Flyweight模式.52aac770.js"><link rel="prefetch" href="/notes/assets/js/page-Fragment.a81098c9.js"><link rel="prefetch" href="/notes/assets/js/page-Freshness.41c3cf72.js"><link rel="prefetch" href="/notes/assets/js/page-Generator.23d4a12a.js"><link rel="prefetch" href="/notes/assets/js/page-Git面试知识点.2457ee57.js"><link rel="prefetch" href="/notes/assets/js/page-HTML5datalist标签.4f1f6ff1.js"><link rel="prefetch" href="/notes/assets/js/page-HTML常用特殊字符.7d215c96.js"><link rel="prefetch" href="/notes/assets/js/page-Home.dfe3b93b.js"><link rel="prefetch" href="/notes/assets/js/page-Hook原理(副作用Hook).1e16a7e9.js"><link rel="prefetch" href="/notes/assets/js/page-Hook原理(概览).6204a657.js"><link rel="prefetch" href="/notes/assets/js/page-Hook原理(状态Hook).8c232cee.js"><link rel="prefetch" href="/notes/assets/js/page-Hybrid.9f05ef5b.js"><link rel="prefetch" href="/notes/assets/js/page-ID选择器.bbbad48c.js"><link rel="prefetch" href="/notes/assets/js/page-ImmutableData.a2e9bc66.js"><link rel="prefetch" href="/notes/assets/js/page-Introduction.38271f00.js"><link rel="prefetch" href="/notes/assets/js/page-JSONstringify悲伤的故事.f4466a49.js"><link rel="prefetch" href="/notes/assets/js/page-JSX和React.bbb28522.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript一行代码.9cca6941.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript实现双向链表.ec26669b.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript执行机制.697a1ebb.js"><link rel="prefetch" href="/notes/assets/js/page-JavaScript设计模式的分类.5c12ac72.js"><link rel="prefetch" href="/notes/assets/js/page-MVC模式.1eec914b.js"><link rel="prefetch" href="/notes/assets/js/page-MVP模式.934b1344.js"><link rel="prefetch" href="/notes/assets/js/page-MVVM.98f72995.js"><link rel="prefetch" href="/notes/assets/js/page-Map.64f61edd.js"><link rel="prefetch" href="/notes/assets/js/page-Mixin模式.ffba597a.js"><link rel="prefetch" href="/notes/assets/js/page-Modulardesign(模块化设计).c6c4e91f.js"><link rel="prefetch" href="/notes/assets/js/page-Never.2feea9cf.js"><link rel="prefetch" href="/notes/assets/js/page-Objectis（）.085d489e.js"><link rel="prefetch" href="/notes/assets/js/page-Portals.3b51662e.js"><link rel="prefetch" href="/notes/assets/js/page-ProgressEvent.f61a9c6a.js"><link rel="prefetch" href="/notes/assets/js/page-Promise.f4e41a3b.js"><link rel="prefetch" href="/notes/assets/js/page-Promise面试题总结.be39fd0f.js"><link rel="prefetch" href="/notes/assets/js/page-Props(v2611).c09ef4d0.js"><link rel="prefetch" href="/notes/assets/js/page-Quirks模式是什么？它和Standards模式有什么区别.124aeb8a.js"><link rel="prefetch" href="/notes/assets/js/page-React+TypeScript规范.9c65d57a.js"><link rel="prefetch" href="/notes/assets/js/page-ReactComponent.3eae8c55.js"><link rel="prefetch" href="/notes/assets/js/page-ReactContext原理.4dfc2141.js"><link rel="prefetch" href="/notes/assets/js/page-ReactJSX.3351c92a.js"><link rel="prefetch" href="/notes/assets/js/page-React中使用TypeScript.47b07cd8.js"><link rel="prefetch" href="/notes/assets/js/page-React中的优先级管理.37e17c1d.js"><link rel="prefetch" href="/notes/assets/js/page-React合成事件.111f39c5.js"><link rel="prefetch" href="/notes/assets/js/page-React工作循环(workLoop).16ba4fb0.js"><link rel="prefetch" href="/notes/assets/js/page-React应用中的高频对象.6dd8351d.js"><link rel="prefetch" href="/notes/assets/js/page-React应用的启动过程.054de2f2.js"><link rel="prefetch" href="/notes/assets/js/page-React应用的宏观包结构(web开发).a5426a29.js"><link rel="prefetch" href="/notes/assets/js/page-React引用传递ForwardingRefs.8b0f6358.js"><link rel="prefetch" href="/notes/assets/js/page-React源码解析.69140ed8.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之位运算.a8d09ea5.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之堆排序.118e1d50.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之栈操作.db571a62.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之深度优先遍历.cdbf0f1a.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之调和算法.a7ca2f9b.js"><link rel="prefetch" href="/notes/assets/js/page-React算法之链表操作.616e34cf.js"><link rel="prefetch" href="/notes/assets/js/page-React调度原理(scheduler).a89a15bc.js"><link rel="prefetch" href="/notes/assets/js/page-React高阶组件(HOC).bbb278e6.js"><link rel="prefetch" href="/notes/assets/js/page-ReflectMetadata.27555649.js"><link rel="prefetch" href="/notes/assets/js/page-Stack.77625d39.js"><link rel="prefetch" href="/notes/assets/js/page-StickyFooter，完美的绝对底部.1adc196e.js"><link rel="prefetch" href="/notes/assets/js/page-String.0d1abe1c.js"><link rel="prefetch" href="/notes/assets/js/page-Suspense组件.b63cdd70.js"><link rel="prefetch" href="/notes/assets/js/page-Symbol.446ec932.js"><link rel="prefetch" href="/notes/assets/js/page-Table组件性能.7fe5b0d3.js"><link rel="prefetch" href="/notes/assets/js/page-ThisType.02774586.js"><link rel="prefetch" href="/notes/assets/js/page-TransformBuildApi.97e4f7d1.js"><link rel="prefetch" href="/notes/assets/js/page-Truthy.82167928.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript37.78828555.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript38.c724cfca.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript39.c4b562e8.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript中unknown与any有啥区别.7bc9b95f.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript中的静态构造函数.ae2b8a73.js"><link rel="prefetch" href="/notes/assets/js/page-TypeScript高效缓存库.4cfa64b0.js"><link rel="prefetch" href="/notes/assets/js/page-VNode.47091c76.js"><link rel="prefetch" href="/notes/assets/js/page-VirtualDOM.80d38be7.js"><link rel="prefetch" href="/notes/assets/js/page-Vue-Router.b0d01168.js"><link rel="prefetch" href="/notes/assets/js/page-VueRouter对象.e46dc887.js"><link rel="prefetch" href="/notes/assets/js/page-Vuejs九个性能优化技巧.68d5dd6d.js"><link rel="prefetch" href="/notes/assets/js/page-Vuejs源码构建.a8e21993.js"><link rel="prefetch" href="/notes/assets/js/page-Vuejs源码目录设计.e4bd01f7.js"><link rel="prefetch" href="/notes/assets/js/page-Vuex.5dee8597.js"><link rel="prefetch" href="/notes/assets/js/page-Vuex初始化.7cce80f6.js"><link rel="prefetch" href="/notes/assets/js/page-Vue事件API.dbc87891.js"><link rel="prefetch" href="/notes/assets/js/page-Vue实例挂载的实现.7aac170f.js"><link rel="prefetch" href="/notes/assets/js/page-Vue模板渲染的原理.9238fb2f.js"><link rel="prefetch" href="/notes/assets/js/page-Vue获取页面元素的相对位置.925e4191.js"><link rel="prefetch" href="/notes/assets/js/page-Webpack.a8664b33.js"><link rel="prefetch" href="/notes/assets/js/page-XMLHttpRequest.59dbc194.js"><link rel="prefetch" href="/notes/assets/js/page-accesskey.d5119bbc.js"><link rel="prefetch" href="/notes/assets/js/page-arguments[]函数参数数组.ba20c0fe.js"><link rel="prefetch" href="/notes/assets/js/page-asyncawait原理.206bbf53.js"><link rel="prefetch" href="/notes/assets/js/page-babel编译原理.dc051d7b.js"><link rel="prefetch" href="/notes/assets/js/page-before和after中双冒号和单冒号.ab0c2e62.js"><link rel="prefetch" href="/notes/assets/js/page-beginWork.c946c22a.js"><link rel="prefetch" href="/notes/assets/js/page-codegen.68126b3e.js"><link rel="prefetch" href="/notes/assets/js/page-coerceRef.6e66d3d9.js"><link rel="prefetch" href="/notes/assets/js/page-commitAllHostEffects.6cf19efe.js"><link rel="prefetch" href="/notes/assets/js/page-commitAllLifeCycles.d620cee7.js"><link rel="prefetch" href="/notes/assets/js/page-commitBeforeMutationLifecycles.103d76ae.js"><link rel="prefetch" href="/notes/assets/js/page-commitDeletion.52aeba89.js"><link rel="prefetch" href="/notes/assets/js/page-commitPlacement.086cbe9b.js"><link rel="prefetch" href="/notes/assets/js/page-commitRoot.ad7e5a88.js"><link rel="prefetch" href="/notes/assets/js/page-commitWork.1ab3b620.js"><link rel="prefetch" href="/notes/assets/js/page-constructor和getInitialState.39b87320.js"><link rel="prefetch" href="/notes/assets/js/page-createComponent.a5b6d3f2.js"><link rel="prefetch" href="/notes/assets/js/page-createElement.6956ff6c.js"><link rel="prefetch" href="/notes/assets/js/page-css优先级：.dfc938fa.js"><link rel="prefetch" href="/notes/assets/js/page-css兼容性整理.00e0cfd5.js"><link rel="prefetch" href="/notes/assets/js/page-css基础面试.e7603a5b.js"><link rel="prefetch" href="/notes/assets/js/page-demo.d8ce8d06.js"><link rel="prefetch" href="/notes/assets/js/page-device.e038e4d2.js"><link rel="prefetch" href="/notes/assets/js/page-divonClick={handlerClick}单击单击div有什么区别.0f1f9935.js"><link rel="prefetch" href="/notes/assets/js/page-es6module.fa9838eb.js"><link rel="prefetch" href="/notes/assets/js/page-event.8d12949e.js"><link rel="prefetch" href="/notes/assets/js/page-exportdefault被认为是有害的.d11fba46.js"><link rel="prefetch" href="/notes/assets/js/page-fiber树构造(初次创建).56944fed.js"><link rel="prefetch" href="/notes/assets/js/page-fiber树构造(基础准备).2a0a40ca.js"><link rel="prefetch" href="/notes/assets/js/page-fiber树构造(对比更新).cb6c1a5b.js"><link rel="prefetch" href="/notes/assets/js/page-fiber树渲染.8d2be0e0.js"><link rel="prefetch" href="/notes/assets/js/page-fixed失效.b970358b.js"><link rel="prefetch" href="/notes/assets/js/page-function.38137a41.js"><link rel="prefetch" href="/notes/assets/js/page-gitrebase.0830750c.js"><link rel="prefetch" href="/notes/assets/js/page-hydrate.7cef46c6.js"><link rel="prefetch" href="/notes/assets/js/page-infer.b5d59f72.js"><link rel="prefetch" href="/notes/assets/js/page-inline-block元素间间距.8e8d6803.js"><link rel="prefetch" href="/notes/assets/js/page-invokeGuardedCallback.d139fdc2.js"><link rel="prefetch" href="/notes/assets/js/page-js奇怪的小问题.96a491dc.js"><link rel="prefetch" href="/notes/assets/js/page-js异步历史.bff1496a.js"><link rel="prefetch" href="/notes/assets/js/page-js总结.51813da1.js"><link rel="prefetch" href="/notes/assets/js/page-js高频手写题.c95b587d.js"><link rel="prefetch" href="/notes/assets/js/page-keep-alive.23e055a0.js"><link rel="prefetch" href="/notes/assets/js/page-lazycomponent.143f3fc0.js"><link rel="prefetch" href="/notes/assets/js/page-libdts.76245918.js"><link rel="prefetch" href="/notes/assets/js/page-loader.08b24bc2.js"><link rel="prefetch" href="/notes/assets/js/page-matcher.2f2d2d8e.js"><link rel="prefetch" href="/notes/assets/js/page-module、export、import分别有什么作用？.06aceb29.js"><link rel="prefetch" href="/notes/assets/js/page-mountIndeterminateComponent.bf6262b9.js"><link rel="prefetch" href="/notes/assets/js/page-mountLazyCompont.d5cb3dce.js"><link rel="prefetch" href="/notes/assets/js/page-newVue发生了什么.cce67fca.js"><link rel="prefetch" href="/notes/assets/js/page-nextTick.fb2b432c.js"><link rel="prefetch" href="/notes/assets/js/page-nginx使用综合场景.4c66cb07.js"><link rel="prefetch" href="/notes/assets/js/page-optimize.98239176.js"><link rel="prefetch" href="/notes/assets/js/page-parse.c714af3c.js"><link rel="prefetch" href="/notes/assets/js/page-patch.69bd4b1e.js"><link rel="prefetch" href="/notes/assets/js/page-plugin.9bf564c8.js"><link rel="prefetch" href="/notes/assets/js/page-plugins.70c5c678.js"><link rel="prefetch" href="/notes/assets/js/page-public设置.7c08d818.js"><link rel="prefetch" href="/notes/assets/js/page-react-dom.d9fda462.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks.24ee55af.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks使用.c0be263c.js"><link rel="prefetch" href="/notes/assets/js/page-react-hooks原理.d68d8631.js"><link rel="prefetch" href="/notes/assets/js/page-react-redux源码.d70e4b8d.js"><link rel="prefetch" href="/notes/assets/js/page-readonly.13519d3b.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileChildren.c97f82a6.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileChildrenArray.ebf1328c.js"><link rel="prefetch" href="/notes/assets/js/page-reconcileSingleElement.91c5a506.js"><link rel="prefetch" href="/notes/assets/js/page-reconciler运作流程.b644f277.js"><link rel="prefetch" href="/notes/assets/js/page-redux源码解读.ae301576.js"><link rel="prefetch" href="/notes/assets/js/page-render.27d24424.js"><link rel="prefetch" href="/notes/assets/js/page-resolveCurrentlyRenderingFiber.4c486882.js"><link rel="prefetch" href="/notes/assets/js/page-set.df79f7bf.js"><link rel="prefetch" href="/notes/assets/js/page-setState.f85c3e5a.js"><link rel="prefetch" href="/notes/assets/js/page-setState执行流程.3e82b96a.js"><link rel="prefetch" href="/notes/assets/js/page-setState背后的批量更新如何实现.1042179b.js"><link rel="prefetch" href="/notes/assets/js/page-slot.54792698.js"><link rel="prefetch" href="/notes/assets/js/page-suspense.480ee2b8.js"><link rel="prefetch" href="/notes/assets/js/page-throwException.82863c1e.js"><link rel="prefetch" href="/notes/assets/js/page-transition-group.cc9310fe.js"><link rel="prefetch" href="/notes/assets/js/page-transition.de361706.js"><link rel="prefetch" href="/notes/assets/js/page-tsconfigjson的行为.5d1d324e.js"><link rel="prefetch" href="/notes/assets/js/page-typescript综合面试.b242200f.js"><link rel="prefetch" href="/notes/assets/js/page-update.42b8b520.js"><link rel="prefetch" href="/notes/assets/js/page-updateClassComponent.bcfe4dcd.js"><link rel="prefetch" href="/notes/assets/js/page-updateContextConsumer.c9652421.js"><link rel="prefetch" href="/notes/assets/js/page-updateContextProvider.1bed8e86.js"><link rel="prefetch" href="/notes/assets/js/page-updateForwardRef.891075bd.js"><link rel="prefetch" href="/notes/assets/js/page-updateFragment.d5c26cba.js"><link rel="prefetch" href="/notes/assets/js/page-updateFunctionalComponent.7b51d57f.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostComponent.eb5eedca.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostRoot.89567556.js"><link rel="prefetch" href="/notes/assets/js/page-updateHostText.15f0edfb.js"><link rel="prefetch" href="/notes/assets/js/page-updateMode.16ed37ff.js"><link rel="prefetch" href="/notes/assets/js/page-updatePortalComponent.04881c76.js"><link rel="prefetch" href="/notes/assets/js/page-updateProfiler.a2298686.js"><link rel="prefetch" href="/notes/assets/js/page-updateSuspenseComponent.9cc3df46.js"><link rel="prefetch" href="/notes/assets/js/page-useCallbackuseMemo.966a71c3.js"><link rel="prefetch" href="/notes/assets/js/page-useContext.9a88724a.js"><link rel="prefetch" href="/notes/assets/js/page-useEffect.3fc7b870.js"><link rel="prefetch" href="/notes/assets/js/page-useState.758d6d98.js"><link rel="prefetch" href="/notes/assets/js/page-v-model.1bbbbabe.js"><link rel="prefetch" href="/notes/assets/js/page-vue响应式详解（重学前端-vue篇1）.4329a208.js"><link rel="prefetch" href="/notes/assets/js/page-vue的优点.138b36b0.js"><link rel="prefetch" href="/notes/assets/js/page-webAnimations.5fec2152.js"><link rel="prefetch" href="/notes/assets/js/page-web工程通用脚手架工具.c955205c.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-1期】理解JavaScript中的执行上下文和执行栈.5b634c46.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-2期】JavaScript深入之执行上下文栈和变量对象.5655f3b1.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-3期】JavaScript深入之内存空间详细图解.c1a53afc.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-4期】JavaScript深入之带走进内存机制.ffb7a8db.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-5期】JavaScript深入之4类常见内存泄漏及如何避免.39d2fda5.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶1-6期】JavaScript预编译.5375287d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-1期】深入浅出图解作用域链和闭包.32292931.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-2期】JavaScript深入之从作用域链理解闭包.e38c3116.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶2-3期】JavaScript深入之闭包面试题解.43b3672d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-1期】JavaScript深入之史上最全--5种this绑定全面解析.e530bc55.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-2期】JavaScript深入之重新认识箭头函数的this.e55e93f2.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-3期】深度广度解析call和apply原理、使用场景及实现.cf94cc45.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-4期】深度解析bind原理、使用场景及模拟实现.6cfc7f3d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶3-5期】深度解析new原理及模拟实现.198c845d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-1期】详细解析赋值、浅拷贝和深拷贝的区别.fbc459f5.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-2期】Objectassign原理及其实现.44a9632d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-3期】面试题之如何实现一个深拷贝.5f5bc108.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶4-4期】Lodash是如何实现深拷贝的.704da529.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-1期】重新认识构造函数、原型和原型链.6c350765.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-2期】图解原型链及其继承优缺点.d04ad89c.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶5-3期】深入探究FunctionObject鸡蛋问题.7fa6ddc5.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-1期】JavaScript高阶函数浅析.1879934e.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-2期】深入高阶函数应用之柯里化.32f2e517.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶6-3期】Array原型方法源码实现大解密.0033fa7d.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-1期】深入浅出节流函数throttle.2fe3e497.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-2期】深入浅出防抖函数debounce.0f41b954.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-3期】Throttle和Debounce在React中的应用.adf07e49.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-4期】深入篇阿里P6必会Lodash防抖节流函数实现原理.e68aa8e6.js"><link rel="prefetch" href="/notes/assets/js/page-【进阶7-5期】浅出篇7个角度吃透Lodash防抖节流原理.082d3e4e.js"><link rel="prefetch" href="/notes/assets/js/page-一、Webpack原理.8f8c82da.js"><link rel="prefetch" href="/notes/assets/js/page-一、为什么JavaScript是单线程？.6ba8a0de.js"><link rel="prefetch" href="/notes/assets/js/page-一、概述.8ae5599f.js"><link rel="prefetch" href="/notes/assets/js/page-一、简介.4e0b9fc5.js"><link rel="prefetch" href="/notes/assets/js/page-一些不能按预期工作的代码.994032a9.js"><link rel="prefetch" href="/notes/assets/js/page-一些常见的Feature需求.720f771f.js"><link rel="prefetch" href="/notes/assets/js/page-一些常见的「bug」并不是bug.5900b8bd.js"><link rel="prefetch" href="/notes/assets/js/page-一正确理解react-router.d9917321.js"><link rel="prefetch" href="/notes/assets/js/page-严格模式.f26ab051.js"><link rel="prefetch" href="/notes/assets/js/page-中介者模式.66718b8b.js"><link rel="prefetch" href="/notes/assets/js/page-事件模块的注入模式.aaeb0105.js"><link rel="prefetch" href="/notes/assets/js/page-事件监听句柄.3de1458c.js"><link rel="prefetch" href="/notes/assets/js/page-事件绑定.24504002.js"><link rel="prefetch" href="/notes/assets/js/page-事件触发.70937c72.js"><link rel="prefetch" href="/notes/assets/js/page-从JavaScript迁移.09d80d8c.js"><link rel="prefetch" href="/notes/assets/js/page-从new一个Vue对象开始.cc2c192a.js"><link rel="prefetch" href="/notes/assets/js/page-从入口开始.2a0132c0.js"><link rel="prefetch" href="/notes/assets/js/page-代理模式.612946c3.js"><link rel="prefetch" href="/notes/assets/js/page-代码分割.a0108ad7.js"><link rel="prefetch" href="/notes/assets/js/page-代码分离.dc3e0340.js"><link rel="prefetch" href="/notes/assets/js/page-传参.b3d5973e.js"><link rel="prefetch" href="/notes/assets/js/page-伪元素.45126f14.js"><link rel="prefetch" href="/notes/assets/js/page-伪类.5662f4a6.js"><link rel="prefetch" href="/notes/assets/js/page-作用.6d8cff96.js"><link rel="prefetch" href="/notes/assets/js/page-使用Es6.d6e3ee93.js"><link rel="prefetch" href="/notes/assets/js/page-依赖收集.e155df30.js"><link rel="prefetch" href="/notes/assets/js/page-元素选择器.2c1210ee.js"><link rel="prefetch" href="/notes/assets/js/page-入口起点(entrypoints).b524e529.js"><link rel="prefetch" href="/notes/assets/js/page-全局属性：用于任何HTML5元素的属性.c95abf0f.js"><link rel="prefetch" href="/notes/assets/js/page-关于ReactHooks.381b58b0.js"><link rel="prefetch" href="/notes/assets/js/page-具体使用.b269c144.js"><link rel="prefetch" href="/notes/assets/js/page-写一个方法去掉字符串中的空格.15c9b961.js"><link rel="prefetch" href="/notes/assets/js/page-减少setter属性的使用.fda10106.js"><link rel="prefetch" href="/notes/assets/js/page-函数.aa4376d2.js"><link rel="prefetch" href="/notes/assets/js/page-函数参数.63c30730.js"><link rel="prefetch" href="/notes/assets/js/page-函数式编程.c74e9ec7.js"><link rel="prefetch" href="/notes/assets/js/page-创建event对象.b829d7b9.js"><link rel="prefetch" href="/notes/assets/js/page-创建数组.5f06987d.js"><link rel="prefetch" href="/notes/assets/js/page-前端缓存.b083cc7c.js"><link rel="prefetch" href="/notes/assets/js/page-动态导入表达式.f7dd67fd.js"><link rel="prefetch" href="/notes/assets/js/page-协变与逆变.491cc364.js"><link rel="prefetch" href="/notes/assets/js/page-单例模式.48e7333e.js"><link rel="prefetch" href="/notes/assets/js/page-原型模式.37069733.js"><link rel="prefetch" href="/notes/assets/js/page-原理图.03c297da.js"><link rel="prefetch" href="/notes/assets/js/page-发射器.1cf2b241.js"><link rel="prefetch" href="/notes/assets/js/page-可能不需要使用派生state.4d214bd2.js"><link rel="prefetch" href="/notes/assets/js/page-可视化拖拽组件库原理分析.b19282ea.js"><link rel="prefetch" href="/notes/assets/js/page-可调用的.36ff8f1c.js"><link rel="prefetch" href="/notes/assets/js/page-合并配置.e27fca6c.js"><link rel="prefetch" href="/notes/assets/js/page-名义化类型.afc13e96.js"><link rel="prefetch" href="/notes/assets/js/page-后代选择器.76557279.js"><link rel="prefetch" href="/notes/assets/js/page-命令模式.bb70cac2.js"><link rel="prefetch" href="/notes/assets/js/page-命令行的行为.8eed48b4.js"><link rel="prefetch" href="/notes/assets/js/page-命名空间.9ec5116f.js"><link rel="prefetch" href="/notes/assets/js/page-响应式对象.d1bdc78c.js"><link rel="prefetch" href="/notes/assets/js/page-块格式化上下文.c97d7224.js"><link rel="prefetch" href="/notes/assets/js/page-基于字符串的枚举.bc4057c2.js"><link rel="prefetch" href="/notes/assets/js/page-基本概念.0e040d38.js"><link rel="prefetch" href="/notes/assets/js/page-基础分类.7dfbdb2d.js"><link rel="prefetch" href="/notes/assets/js/page-声明空间.5bc39df9.js"><link rel="prefetch" href="/notes/assets/js/page-外观模式.c439c4b1.js"><link rel="prefetch" href="/notes/assets/js/page-外边距重叠.5db6e339.js"><link rel="prefetch" href="/notes/assets/js/page-大文件上传和断点续传.e0f9407d.js"><link rel="prefetch" href="/notes/assets/js/page-如何关闭表单自动填充.ba036e3d.js"><link rel="prefetch" href="/notes/assets/js/page-子选择器.aea200d6.js"><link rel="prefetch" href="/notes/assets/js/page-字面量类型.1afcb93f.js"><link rel="prefetch" href="/notes/assets/js/page-实现一个web代码模板快速生成CLI工具.834bfaa0.js"><link rel="prefetch" href="/notes/assets/js/page-对象字面量的惰性初始化.601c1fc2.js"><link rel="prefetch" href="/notes/assets/js/page-层叠上下文.ddca19ec.js"><link rel="prefetch" href="/notes/assets/js/page-展开语法.c876244f.js"><link rel="prefetch" href="/notes/assets/js/page-展示长列表.562f09b8.js"><link rel="prefetch" href="/notes/assets/js/page-属性选择器.17a0733c.js"><link rel="prefetch" href="/notes/assets/js/page-工具类.39c7d8c6.js"><link rel="prefetch" href="/notes/assets/js/page-工厂模式.ff661a6c.js"><link rel="prefetch" href="/notes/assets/js/page-布局和包含块.f8db8a87.js"><link rel="prefetch" href="/notes/assets/js/page-常用块级元素：.ad0eba64.js"><link rel="prefetch" href="/notes/assets/js/page-常见的Error.b1f28eb4.js"><link rel="prefetch" href="/notes/assets/js/page-并发模型与事件循环.c3a458a4.js"><link rel="prefetch" href="/notes/assets/js/page-建造者模式.16b4d58a.js"><link rel="prefetch" href="/notes/assets/js/page-开始.07da2ea5.js"><link rel="prefetch" href="/notes/assets/js/page-异常处理.3d53d5d3.js"><link rel="prefetch" href="/notes/assets/js/page-异步组件.47b6aeee.js"><link rel="prefetch" href="/notes/assets/js/page-引入.3fc87578.js"><link rel="prefetch" href="/notes/assets/js/page-引用.df6ce8d3.js"><link rel="prefetch" href="/notes/assets/js/page-引用官网.ccb07d29.js"><link rel="prefetch" href="/notes/assets/js/page-总结.ae287b5a.js"><link rel="prefetch" href="/notes/assets/js/page-惰性初始模式.9385ab88.js"><link rel="prefetch" href="/notes/assets/js/page-扩展.814e6dff.js"><link rel="prefetch" href="/notes/assets/js/page-扫描器.1903d057.js"><link rel="prefetch" href="/notes/assets/js/page-抽象DOM树.79f1565b.js"><link rel="prefetch" href="/notes/assets/js/page-抽象语法树.c505c606.js"><link rel="prefetch" href="/notes/assets/js/page-接口.2e4a8719.js"><link rel="prefetch" href="/notes/assets/js/page-插件.f63f7e43.js"><link rel="prefetch" href="/notes/assets/js/page-操作DOM.771d0531.js"><link rel="prefetch" href="/notes/assets/js/page-支持JSX.9d6c50e5.js"><link rel="prefetch" href="/notes/assets/js/page-改善antdTable组件的渲染效率.743ed63e.js"><link rel="prefetch" href="/notes/assets/js/page-数据绑定原理.1f452126.js"><link rel="prefetch" href="/notes/assets/js/page-数据驱动.4f7626f4.js"><link rel="prefetch" href="/notes/assets/js/page-数组方法另一个角度总结.cc582cd5.js"><link rel="prefetch" href="/notes/assets/js/page-文档声明区别.ee8cebdb.js"><link rel="prefetch" href="/notes/assets/js/page-新js环境要求.c14a95dc.js"><link rel="prefetch" href="/notes/assets/js/page-暴露模块模式.718b0abf.js"><link rel="prefetch" href="/notes/assets/js/page-服务器基础.5a34c3fb.js"><link rel="prefetch" href="/notes/assets/js/page-术语表.00c04433.js"><link rel="prefetch" href="/notes/assets/js/page-构建切换.06f09fa0.js"><link rel="prefetch" href="/notes/assets/js/page-构造器模式.a49751b6.js"><link rel="prefetch" href="/notes/assets/js/page-枚举.be6b8d74.js"><link rel="prefetch" href="/notes/assets/js/page-柯里化.f81b8723.js"><link rel="prefetch" href="/notes/assets/js/page-标准的CSS的盒子模型？低版本IE的盒子模型.7c971d18.js"><link rel="prefetch" href="/notes/assets/js/page-检查器.65d814a9.js"><link rel="prefetch" href="/notes/assets/js/page-检测变化的注意事项.4a067fd8.js"><link rel="prefetch" href="/notes/assets/js/page-概念.60a97d37.js"><link rel="prefetch" href="/notes/assets/js/page-概览.703a53ac.js"><link rel="prefetch" href="/notes/assets/js/page-模块.d501f90d.js"><link rel="prefetch" href="/notes/assets/js/page-模块化模式.7f6a8da0.js"><link rel="prefetch" href="/notes/assets/js/page-正则表达式.41e66bb3.js"><link rel="prefetch" href="/notes/assets/js/page-泛型.61926067.js"><link rel="prefetch" href="/notes/assets/js/page-泛型的实例化类型.068633cf.js"><link rel="prefetch" href="/notes/assets/js/page-派发更新.6b3791c2.js"><link rel="prefetch" href="/notes/assets/js/page-流动的类型.941c7922.js"><link rel="prefetch" href="/notes/assets/js/page-浏览器输入URL.46610dcc.js"><link rel="prefetch" href="/notes/assets/js/page-浏览器重绘与回流.56af5f6a.js"><link rel="prefetch" href="/notes/assets/js/page-深入TypeScript.346b5108.js"><link rel="prefetch" href="/notes/assets/js/page-深入响应式原理.9e834b8c.js"><link rel="prefetch" href="/notes/assets/js/page-深入源码剖析componentWillXXX为什么UNSAFE.aea162e6.js"><link rel="prefetch" href="/notes/assets/js/page-混合.b5b954ea.js"><link rel="prefetch" href="/notes/assets/js/page-状态与副作用.977a96a1.js"><link rel="prefetch" href="/notes/assets/js/page-状态函数.d1814914.js"><link rel="prefetch" href="/notes/assets/js/page-环境声明.9abb28a3.js"><link rel="prefetch" href="/notes/assets/js/page-生命周期.1294a579.js"><link rel="prefetch" href="/notes/assets/js/page-用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值.a4dee7e7.js"><link rel="prefetch" href="/notes/assets/js/page-相邻兄弟选择器.dbcf695e.js"><link rel="prefetch" href="/notes/assets/js/page-知识体系.65944f3a.js"><link rel="prefetch" href="/notes/assets/js/page-程序.a65ac1c4.js"><link rel="prefetch" href="/notes/assets/js/page-第10天简要描述下什么是回调函数并写一个例子出来.5e20c5dd.js"><link rel="prefetch" href="/notes/assets/js/page-第11天简要描述下JS有哪些内置的对象.6e93d0e3.js"><link rel="prefetch" href="/notes/assets/js/page-第12天写一个获取当前url查询字符串中的参数的方法.1fb15fc9.js"><link rel="prefetch" href="/notes/assets/js/page-第13天说说你对javascript的作用域的理解.e6eac7fd.js"><link rel="prefetch" href="/notes/assets/js/page-第14天什么是闭包？优缺点分别是什么？.947fc3df.js"><link rel="prefetch" href="/notes/assets/js/page-第15天写一个数组去重的方法（支持多维数组）.5c4e3d20.js"><link rel="prefetch" href="/notes/assets/js/page-第16天返回到顶部的方法有哪些？把其中一个方法出来.a5de7cc1.js"><link rel="prefetch" href="/notes/assets/js/page-第17天typeof('abc')和typeof'abc'都是string,那么typeof是操作符还是函数？.4c27b308.js"><link rel="prefetch" href="/notes/assets/js/page-第18天你理解的usestrict;是什么使用它有什么优缺点？.18705902.js"><link rel="prefetch" href="/notes/assets/js/page-第19天attribute和property有什么不同？.1d7a7a6d.js"><link rel="prefetch" href="/notes/assets/js/page-第1天用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值.8fdf8550.js"><link rel="prefetch" href="/notes/assets/js/page-第20天写一个验证身份证号的方法.1a0ea3b9.js"><link rel="prefetch" href="/notes/assets/js/page-第21天写一个方法验证是否为中文.109f9dfc.js"><link rel="prefetch" href="/notes/assets/js/page-第22天你对new操作符的理解是什么？手动实现一个new方法.19c1bb43.js"><link rel="prefetch" href="/notes/assets/js/page-第23天01+02、01+03和0102分别等于多少？并解释下为什么？.2f2056c3.js"><link rel="prefetch" href="/notes/assets/js/page-第24天如何快速让一个数组乱序，写出来.19dc7c1a.js"><link rel="prefetch" href="/notes/assets/js/page-第25天写一个判断设备来源的方法.4075d056.js"><link rel="prefetch" href="/notes/assets/js/page-第26天说说bind、call、apply的区别？并手写实现一个bind的方法.5df9aa2e.js"><link rel="prefetch" href="/notes/assets/js/page-第27天说说你对arguments的理解，它是数组吗？.42760d21.js"><link rel="prefetch" href="/notes/assets/js/page-第28天解释下这段代码的意思！.cf889e1a.js"><link rel="prefetch" href="/notes/assets/js/page-第29天写一个获取数组的最大值、最小值的方法.fe95fbd7.js"><link rel="prefetch" href="/notes/assets/js/page-第2天写一个方法去掉字符串中的空格.7d76acf0.js"><link rel="prefetch" href="/notes/assets/js/page-第30天写一个方法判断字符串是否为回文字符串.03192863.js"><link rel="prefetch" href="/notes/assets/js/page-第3天去除字符串中最后一个指定的字符.41cb04ca.js"><link rel="prefetch" href="/notes/assets/js/page-第4天写一个方法把下划线命名转成大驼峰命名.a5bf1fd7.js"><link rel="prefetch" href="/notes/assets/js/page-第5天写一个把字符串大小写切换的方法.554506ee.js"><link rel="prefetch" href="/notes/assets/js/page-第6天写一个去除制表符和换行符的方法.d7664ad8.js"><link rel="prefetch" href="/notes/assets/js/page-第7天统计某一字符或字符串在另一个字符串中出现的次数.fc1eb476.js"><link rel="prefetch" href="/notes/assets/js/page-第8天写一个加密字符串的方法.62090bf5.js"><link rel="prefetch" href="/notes/assets/js/page-第9天写一个判断数据类型的方法.11bc7bda.js"><link rel="prefetch" href="/notes/assets/js/page-第一套js综合基础面试题.d70ec353.js"><link rel="prefetch" href="/notes/assets/js/page-第一套webpack综合基础面试题.8a4e9890.js"><link rel="prefetch" href="/notes/assets/js/page-管理资源.030335de.js"><link rel="prefetch" href="/notes/assets/js/page-类.d93db169.js"><link rel="prefetch" href="/notes/assets/js/page-类型保护.7c17aa11.js"><link rel="prefetch" href="/notes/assets/js/page-类型兼容性.f28d7fba.js"><link rel="prefetch" href="/notes/assets/js/page-类型守卫.92fbffaa.js"><link rel="prefetch" href="/notes/assets/js/page-类型安全的EventEmitter.42a1c63f.js"><link rel="prefetch" href="/notes/assets/js/page-类型推断.9b542eec.js"><link rel="prefetch" href="/notes/assets/js/page-类型断言.7983b400.js"><link rel="prefetch" href="/notes/assets/js/page-类型系统的行为.79236332.js"><link rel="prefetch" href="/notes/assets/js/page-类是有用的.6c4e81e5.js"><link rel="prefetch" href="/notes/assets/js/page-类选择器.e565c76b.js"><link rel="prefetch" href="/notes/assets/js/page-索引签名.f4f371de.js"><link rel="prefetch" href="/notes/assets/js/page-组件化.6b4f617e.js"><link rel="prefetch" href="/notes/assets/js/page-组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除.6d38a6f6.js"><link rel="prefetch" href="/notes/assets/js/page-组件更新.d4b87a5b.js"><link rel="prefetch" href="/notes/assets/js/page-组件注册.f1ed2495.js"><link rel="prefetch" href="/notes/assets/js/page-组件类.8bf0adbf.js"><link rel="prefetch" href="/notes/assets/js/page-组合模式.1b27c6cc.js"><link rel="prefetch" href="/notes/assets/js/page-绑定器.ac7ae4ee.js"><link rel="prefetch" href="/notes/assets/js/page-结论.c04ab166.js"><link rel="prefetch" href="/notes/assets/js/page-编译.fb793081.js"><link rel="prefetch" href="/notes/assets/js/page-编译上下文.e010be74.js"><link rel="prefetch" href="/notes/assets/js/page-编译入口.2870e3c9.js"><link rel="prefetch" href="/notes/assets/js/page-网站favicon图标.c1243a1a.js"><link rel="prefetch" href="/notes/assets/js/page-自定义hooks.6c3ad7a2.js"><link rel="prefetch" href="/notes/assets/js/page-获取localStorage和sessionStorage当前已存储大小.fbdddb02.js"><link rel="prefetch" href="/notes/assets/js/page-虚拟DOM和DOM-diff.95d7bc11.js"><link rel="prefetch" href="/notes/assets/js/page-表单数据.b522cde7.js"><link rel="prefetch" href="/notes/assets/js/page-装饰器.b4ebf59d.js"><link rel="prefetch" href="/notes/assets/js/page-装饰模式.104ad7f6.js"><link rel="prefetch" href="/notes/assets/js/page-观察者模式.02176ac8.js"><link rel="prefetch" href="/notes/assets/js/page-解析器.b64423a9.js"><link rel="prefetch" href="/notes/assets/js/page-解读Errors.32787e54.js"><link rel="prefetch" href="/notes/assets/js/page-计算属性VS侦听属性.9d9cb3b4.js"><link rel="prefetch" href="/notes/assets/js/page-认识Flow.e308b8c5.js"><link rel="prefetch" href="/notes/assets/js/page-评论.e8c24c81.js"><link rel="prefetch" href="/notes/assets/js/page-详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景.11d736e1.js"><link rel="prefetch" href="/notes/assets/js/page-说说对SPA单页面的理解，它的优缺点分别是什么？.a9b56a69.js"><link rel="prefetch" href="/notes/assets/js/page-调和的过程.5f93084d.js"><link rel="prefetch" href="/notes/assets/js/page-调度原理.392897ea.js"><link rel="prefetch" href="/notes/assets/js/page-谨慎使用--outFile.d0bee75e.js"><link rel="prefetch" href="/notes/assets/js/page-超链接target属性.bf9dbc49.js"><link rel="prefetch" href="/notes/assets/js/page-路径切换.9746ae17.js"><link rel="prefetch" href="/notes/assets/js/page-路由注册.008f596e.js"><link rel="prefetch" href="/notes/assets/js/page-输出(output).87d05a82.js"><link rel="prefetch" href="/notes/assets/js/page-辨析联合类型.c49871af.js"><link rel="prefetch" href="/notes/assets/js/page-迭代协议.9538062f.js"><link rel="prefetch" href="/notes/assets/js/page-迭代器模式.caa54720.js"><link rel="prefetch" href="/notes/assets/js/page-适配器模式.5132066f.js"><link rel="prefetch" href="/notes/assets/js/page-选择器列表.02be3c2e.js"><link rel="prefetch" href="/notes/assets/js/page-通用兄弟选择器.44f1acef.js"><link rel="prefetch" href="/notes/assets/js/page-通过标签语义化优化SEO.a54403be.js"><link rel="prefetch" href="/notes/assets/js/page-通配选择器.664821f6.js"><link rel="prefetch" href="/notes/assets/js/page-需求分析.bd656c54.js"><link rel="prefetch" href="/notes/assets/js/page-非ReactJSX.9f05d6e4.js"><link rel="prefetch" href="/notes/assets/js/page-项目性能优化.75f67f82.js"><link rel="prefetch" href="/notes/assets/js/page-🗿HEAD.35a8118a.js"><link rel="prefetch" href="/notes/assets/js/vendors~flowchart.553504a1.js"><link rel="prefetch" href="/notes/assets/js/vendors~mermaid.32e6aacf.js"><link rel="prefetch" href="/notes/assets/js/vendors~photo-swipe.9372e924.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.5a16df27.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-navbar has-sidebar has-anchor"><header class="navbar"><!----> <div class="content__navbar-start"></div> <button title="Sidebar Button" class="sidebar-button"><span class="icon"></span></button> <a href="/notes/" class="home-link router-link-active"><!----> <!----> <span class="site-name can-hide">前端 学习</span></a> <!----> <div class="content__navbar-center"></div> <div class="links"><button tabindex="-1" aria-hidden="true" class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><ul class="themecolor-select"><label for="themecolor-select">Theme Color:</label> <li><span class="default-theme"></span></li> </ul> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">Theme Mode:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0 0 42.667-42.667V128a42.667 42.667 0 0 0-85.334 0v85.333A42.667 42.667 0 0 0 512 256zm384 213.333h-85.333a42.667 42.667 0 0 0 0 85.334H896a42.667 42.667 0 0 0 0-85.334zM256 512a42.667 42.667 0 0 0-42.667-42.667H128a42.667 42.667 0 0 0 0 85.334h85.333A42.667 42.667 0 0 0 256 512zm9.387-298.667a42.667 42.667 0 0 0-59.307 62.72l61.44 59.307a42.667 42.667 0 0 0 31.147 11.947 42.667 42.667 0 0 0 30.72-13.227 42.667 42.667 0 0 0 0-60.16zm459.946 133.974a42.667 42.667 0 0 0 29.44-11.947l61.44-59.307a42.667 42.667 0 0 0-57.6-62.72l-61.44 60.587a42.667 42.667 0 0 0 0 60.16 42.667 42.667 0 0 0 28.16 13.227zM512 768a42.667 42.667 0 0 0-42.667 42.667V896a42.667 42.667 0 0 0 85.334 0v-85.333A42.667 42.667 0 0 0 512 768zm244.48-79.36a42.667 42.667 0 0 0-59.307 61.44l61.44 60.587a42.667 42.667 0 0 0 29.44 11.946 42.667 42.667 0 0 0 30.72-12.8 42.667 42.667 0 0 0 0-60.586zm-488.96 0-61.44 59.307a42.667 42.667 0 0 0 0 60.586 42.667 42.667 0 0 0 30.72 12.8 42.667 42.667 0 0 0 28.587-10.666l61.44-59.307a42.667 42.667 0 0 0-59.307-61.44zM512 341.333A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 0 0-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 0 0-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js" class="dropdown-title"><span class="title"><!---->
        js
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/mozillajs/baseObject/symbol.html" class="nav-link"><!---->
  mozilla：基本对象
</a></li><li class="dropdown-item"><a href="/notes/jsInterview/baseInterview.html" class="nav-link"><!---->
  基础面试题
</a></li><li class="dropdown-item"><a href="/notes/js/stack/executionStack.html" class="nav-link"><!---->
  js 概念
</a></li><li class="dropdown-item"><a href="/notes/es6/interview1.html" class="nav-link"><!---->
  es6
</a></li><li class="dropdown-item"><a href="/notes/es7/interview1.html" class="nav-link"><!---->
  es7
</a></li><li class="dropdown-item"><a href="/notes/es8/interview1.html" class="nav-link"><!---->
  es8
</a></li><li class="dropdown-item"><a href="/notes/es9/interview1.html" class="nav-link"><!---->
  es9
</a></li><li class="dropdown-item"><a href="/notes/es10/interview1.html" class="nav-link"><!---->
  es10
</a></li><li class="dropdown-item"><a href="/notes/ts/jsx/support.html" class="nav-link"><!---->
  JSX
</a></li><li class="dropdown-item"><a href="/notes/ts/project/inDepthTs.html" class="nav-link"><!---->
  TypeScript 项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title"><!---->
        css
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/mozillaCss/reference/universalSelectors.html" class="nav-link"><!---->
  第 1 期：CSS API
</a></li><li class="dropdown-item"><a href="/notes/css/interview/baseCss.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html" class="dropdown-title"><span class="title"><!---->
        html
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/html/interview/linkImport.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="端" class="dropdown-title"><span class="title"><!---->
        端
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/browser/interview/baseInterview.html" class="nav-link"><!---->
  基础浏览器
</a></li><li class="dropdown-item"><a href="/notes/http/interview/baseInterview.html" class="nav-link"><!---->
  基础http
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title"><!---->
        工具
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/webpack/interview/webpackInterview.html" class="nav-link"><!---->
  webpack
</a></li><li class="dropdown-item"><a href="/notes/esbuild/description.html" class="nav-link"><!---->
  esbuild
</a></li><li class="dropdown-item"><a href="/notes/rollup/introduction.html" class="nav-link"><!---->
  rollup
</a></li><li class="dropdown-item"><a href="/notes/git/indx.html" class="nav-link"><!---->
  git
</a></li><li class="dropdown-item"><a href="/notes/nginx/base.html" class="nav-link"><!---->
  nginx
</a></li><li class="dropdown-item"><a href="/notes/cli/base.html" class="nav-link"><!---->
  cli
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title"><!---->
        react
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/ILoveDevelop/react/principle/base.html" class="nav-link"><!---->
  react 源码阅读 代码视角
</a></li><li class="dropdown-item"><a href="/notes/react/preparation/idea.html" class="nav-link"><!---->
  react 源码阅读 思想视角
</a></li><li class="dropdown-item"><a href="/notes/react-illustration-series/main/macro-structure.html" class="nav-link"><!---->
  图解React源码
</a></li><li class="dropdown-item"><a href="/notes/umi/interview/pluginDva.html" class="nav-link"><!---->
  umi
</a></li><li class="dropdown-item"><a href="/notes/reactInterview/interview1.html" class="nav-link"><!---->
  整理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue" class="dropdown-title"><span class="title"><!---->
        vue
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/vue/prepare/flow.html" class="nav-link"><!---->
  第 1 期：源码解读-准备工作
</a></li><li class="dropdown-item"><a href="/notes/vue/data-driven/_index.html" class="nav-link"><!---->
  第2期：源码解读-数据驱动
</a></li><li class="dropdown-item"><a href="/notes/vue/components/create-component.html" class="nav-link"><!---->
  第3期：源码解读-组件化
</a></li><li class="dropdown-item"><a href="/notes/vue/reactive/reactive-object.html" class="nav-link"><!---->
  第4期：源码解读-深入响应式原理
</a></li><li class="dropdown-item"><a href="/notes/vue/compile/entrance.html" class="nav-link"><!---->
  第5期：源码解读-编译
</a></li><li class="dropdown-item"><a href="/notes/vue/extend/event.html" class="nav-link"><!---->
  第6期：源码解读-扩展
</a></li><li class="dropdown-item"><a href="/notes/vue/vue-router/install.html" class="nav-link"><!---->
  第7期：源码解读-VueRouter
</a></li><li class="dropdown-item"><a href="/notes/vue/vuex/idex.html" class="nav-link"><!---->
  第8期：源码解读-Vuex
</a></li><li class="dropdown-item"><a href="/notes/vue/interview/baseInterview.html" class="nav-link"><!---->
  第9期：基础面试题
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="性能优化" class="dropdown-title"><span class="title"><!---->
        性能优化
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/performance/vue/vue2Base.html" class="nav-link"><!---->
  vue-性能优化
</a></li><li class="dropdown-item"><a href="/notes/performance/react/reactBase.html" class="nav-link"><!---->
  react-性能优化
</a></li><li class="dropdown-item"><a href="/notes/performance/base/drag1.html" class="nav-link"><!---->
  组件设计
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法&amp;设计" class="dropdown-title"><span class="title"><!---->
        算法&amp;设计
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/notes/algorithm/interview/baseInterview.html" class="nav-link"><!---->
  第 1 期：基础面试题
</a></li><li class="dropdown-item"><a href="/notes/design/overview.html" class="nav-link"><!---->
  设计模式
</a></li></ul></div></div></nav> <!----> <!----> <!----> <div class="content__navbar-end"></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <!----> <div class="content__sidebar-top"></div> <nav class="sidebar-nav-links"><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="js" class="dropdown-title"><span class="title"><!---->
      js
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/mozillajs/baseObject/symbol.html" class="nav-link"><!---->
  mozilla：基本对象
</a></li><li class="dropdown-item"><!----> <a href="/notes/jsInterview/baseInterview.html" class="nav-link"><!---->
  基础面试题
</a></li><li class="dropdown-item"><!----> <a href="/notes/js/stack/executionStack.html" class="nav-link"><!---->
  js 概念
</a></li><li class="dropdown-item"><!----> <a href="/notes/es6/interview1.html" class="nav-link"><!---->
  es6
</a></li><li class="dropdown-item"><!----> <a href="/notes/es7/interview1.html" class="nav-link"><!---->
  es7
</a></li><li class="dropdown-item"><!----> <a href="/notes/es8/interview1.html" class="nav-link"><!---->
  es8
</a></li><li class="dropdown-item"><!----> <a href="/notes/es9/interview1.html" class="nav-link"><!---->
  es9
</a></li><li class="dropdown-item"><!----> <a href="/notes/es10/interview1.html" class="nav-link"><!---->
  es10
</a></li><li class="dropdown-item"><!----> <a href="/notes/ts/jsx/support.html" class="nav-link"><!---->
  JSX
</a></li><li class="dropdown-item"><!----> <a href="/notes/ts/project/inDepthTs.html" class="nav-link"><!---->
  TypeScript 项目
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title"><!---->
      css
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/mozillaCss/reference/universalSelectors.html" class="nav-link"><!---->
  第 1 期：CSS API
</a></li><li class="dropdown-item"><!----> <a href="/notes/css/interview/baseCss.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="html" class="dropdown-title"><span class="title"><!---->
      html
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/html/interview/linkImport.html" class="nav-link"><!---->
  零散记录
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="端" class="dropdown-title"><span class="title"><!---->
      端
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/browser/interview/baseInterview.html" class="nav-link"><!---->
  基础浏览器
</a></li><li class="dropdown-item"><!----> <a href="/notes/http/interview/baseInterview.html" class="nav-link"><!---->
  基础http
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title"><!---->
      工具
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/webpack/interview/webpackInterview.html" class="nav-link"><!---->
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/notes/esbuild/description.html" class="nav-link"><!---->
  esbuild
</a></li><li class="dropdown-item"><!----> <a href="/notes/rollup/introduction.html" class="nav-link"><!---->
  rollup
</a></li><li class="dropdown-item"><!----> <a href="/notes/git/indx.html" class="nav-link"><!---->
  git
</a></li><li class="dropdown-item"><!----> <a href="/notes/nginx/base.html" class="nav-link"><!---->
  nginx
</a></li><li class="dropdown-item"><!----> <a href="/notes/cli/base.html" class="nav-link"><!---->
  cli
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title"><!---->
      react
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/ILoveDevelop/react/principle/base.html" class="nav-link"><!---->
  react 源码阅读 代码视角
</a></li><li class="dropdown-item"><!----> <a href="/notes/react/preparation/idea.html" class="nav-link"><!---->
  react 源码阅读 思想视角
</a></li><li class="dropdown-item"><!----> <a href="/notes/react-illustration-series/main/macro-structure.html" class="nav-link"><!---->
  图解React源码
</a></li><li class="dropdown-item"><!----> <a href="/notes/umi/interview/pluginDva.html" class="nav-link"><!---->
  umi
</a></li><li class="dropdown-item"><!----> <a href="/notes/reactInterview/interview1.html" class="nav-link"><!---->
  整理
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="vue" class="dropdown-title"><span class="title"><!---->
      vue
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/vue/prepare/flow.html" class="nav-link"><!---->
  第 1 期：源码解读-准备工作
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/data-driven/_index.html" class="nav-link"><!---->
  第2期：源码解读-数据驱动
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/components/create-component.html" class="nav-link"><!---->
  第3期：源码解读-组件化
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/reactive/reactive-object.html" class="nav-link"><!---->
  第4期：源码解读-深入响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/compile/entrance.html" class="nav-link"><!---->
  第5期：源码解读-编译
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/extend/event.html" class="nav-link"><!---->
  第6期：源码解读-扩展
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/vue-router/install.html" class="nav-link"><!---->
  第7期：源码解读-VueRouter
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/vuex/idex.html" class="nav-link"><!---->
  第8期：源码解读-Vuex
</a></li><li class="dropdown-item"><!----> <a href="/notes/vue/interview/baseInterview.html" class="nav-link"><!---->
  第9期：基础面试题
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="性能优化" class="dropdown-title"><span class="title"><!---->
      性能优化
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/performance/vue/vue2Base.html" class="nav-link"><!---->
  vue-性能优化
</a></li><li class="dropdown-item"><!----> <a href="/notes/performance/react/reactBase.html" class="nav-link"><!---->
  react-性能优化
</a></li><li class="dropdown-item"><!----> <a href="/notes/performance/base/drag1.html" class="nav-link"><!---->
  组件设计
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="算法&amp;设计" class="dropdown-title"><span class="title"><!---->
      算法&amp;设计
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/algorithm/interview/baseInterview.html" class="nav-link"><!---->
  第 1 期：基础面试题
</a></li><li class="dropdown-item"><!----> <a href="/notes/design/overview.html" class="nav-link"><!---->
  设计模式
</a></li></ul></div></div> <!----></nav> <!----> <div class="content__sidebar-center"></div> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><!----> <span class="title">react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/performance/react/reactBase/" aria-current="page" class="active sidebar-link">React 运行时优化方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#几大-js-框架的设计思路" class="sidebar-link">几大 JS 框架的设计思路</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#什么是编译时优化" class="sidebar-link">什么是编译时优化</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#死磕运行时" class="sidebar-link">死磕运行时</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-15-半自动批处理" class="sidebar-link">React 15-半自动批处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#架构" class="sidebar-link heading3">架构</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#批处理" class="sidebar-link heading3">批处理</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-15-的缺陷" class="sidebar-link heading3">React 15 的缺陷</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-16-让-concurrent-mode-成为可能" class="sidebar-link">React 16 - 让 Concurrent Mode 成为可能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#架构-2" class="sidebar-link heading3">架构</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#concurrent-mode" class="sidebar-link heading3">Concurrent Mode</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#底层架构-fiber" class="sidebar-link heading3">底层架构 - Fiber</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#调度器-scheduler" class="sidebar-link heading3">调度器 - Scheduler</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#优先级控制" class="sidebar-link heading3">优先级控制</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#生命周期的改变" class="sidebar-link heading3">生命周期的改变</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#suspense" class="sidebar-link heading3">Suspense</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-16-的缺陷" class="sidebar-link heading3">React 16 的缺陷</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-17-稳定-concurrent-mode-的过渡版本" class="sidebar-link">React 17 - 稳定 Concurrent Mode 的过渡版本</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#没有新特性" class="sidebar-link heading3">没有新特性？</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#实现多版本共存" class="sidebar-link heading3">实现多版本共存</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#新的优先级算法-lanes" class="sidebar-link heading3">新的优先级算法 - lanes</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#react-18-更灵活-concurrent-renderring" class="sidebar-link">React 18 - 更灵活 Concurrent Renderring</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#createroot" class="sidebar-link heading3">createRoot</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#批处理的优化" class="sidebar-link heading3">批处理的优化</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#starttransition" class="sidebar-link heading3">startTransition</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#usedeferredvalue" class="sidebar-link heading3">useDeferredValue</a></li><li class="sidebar-sub-header"><a href="/notes/performance/react/reactBase/#ssr-下的懒加载支持" class="sidebar-link heading3">SSR 下的懒加载支持</a></li></ul></li></ul></li><li><a href="/notes/performance/react/reactTypescript/" class="sidebar-link">React 中使用TypeScript</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">基础优化</span> <span class="arrow right"></span></p> <!----></section></li></ul> <!----> <div class="content__sidebar-bottom"></div> <!----></aside> <main class="page"><nav class="breadcrumb disable"><!----></nav> <!----> <div class="content__page-top"></div> <div vocab="https://schema.org/" typeof="Article" class="page-title"><h1><!----> <span property="headline">React 运行时优化方案</span></h1> <div class="page-info"><!----> <!----><!----><span aria-label="Writing Date📅" data-balloon-pos="down" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H180.6A134.314 134.314 0 0 0 46.66 277.595v535.756A134.314 134.314 0 0 0 180.6 947.289h669.74a134.36 134.36 0 0 0 133.94-133.938V277.595a134.314 134.314 0 0 0-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 0 1-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 0 1-33.472 33.473z" fill="currentColor"></path></svg> <span property="datePublished">2021-11-8</span></span><!----><!----><span aria-label="Reading Time⌛" data-balloon-pos="down" class="reading-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon timer-icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z" fill="currentColor"></path></svg> <span>About 35 min</span> <meta property="timeRequired" content="PT35M"></span></div> <!----> <hr></div> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor"><a href="/notes/performance/react/reactBase/#几大-js-框架的设计思路" class="anchor-link heading2"><div>几大 JS 框架的设计思路</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#什么是编译时优化" class="anchor-link heading2"><div>什么是编译时优化</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#死磕运行时" class="anchor-link heading2"><div>死磕运行时</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-15-半自动批处理" class="anchor-link heading2"><div>React 15-半自动批处理</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#架构" class="anchor-link heading3"><div>架构</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#批处理" class="anchor-link heading3"><div>批处理</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-15-的缺陷" class="anchor-link heading3"><div>React 15 的缺陷</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-16-让-concurrent-mode-成为可能" class="anchor-link heading2"><div>React 16 - 让 Concurrent Mode 成为可能</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#架构-2" class="anchor-link heading3"><div>架构</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#concurrent-mode" class="anchor-link heading3"><div>Concurrent Mode</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#底层架构-fiber" class="anchor-link heading3"><div>底层架构 - Fiber</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#调度器-scheduler" class="anchor-link heading3"><div>调度器 - Scheduler</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#优先级控制" class="anchor-link heading3"><div>优先级控制</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#生命周期的改变" class="anchor-link heading3"><div>生命周期的改变</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#suspense" class="anchor-link heading3"><div>Suspense</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-16-的缺陷" class="anchor-link heading3"><div>React 16 的缺陷</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-17-稳定-concurrent-mode-的过渡版本" class="anchor-link heading2"><div>React 17 - 稳定 Concurrent Mode 的过渡版本</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#没有新特性" class="anchor-link heading3"><div>没有新特性？</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#实现多版本共存" class="anchor-link heading3"><div>实现多版本共存</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#新的优先级算法-lanes" class="anchor-link heading3"><div>新的优先级算法 - lanes</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#react-18-更灵活-concurrent-renderring" class="anchor-link heading2"><div>React 18 - 更灵活 Concurrent Renderring</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#createroot" class="anchor-link heading3"><div>createRoot</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#批处理的优化" class="anchor-link heading3"><div>批处理的优化</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#starttransition" class="anchor-link heading3"><div>startTransition</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#usedeferredvalue" class="anchor-link heading3"><div>useDeferredValue</div></a></li><li class="anchor"><a href="/notes/performance/react/reactBase/#ssr-下的懒加载支持" class="anchor-link heading3"><div>SSR 下的懒加载支持</div></a></li></ul></div></aside></div> <!----> <div class="content__content-top"></div> <div class="theme-default-content content__default"><h1 id="react-运行时优化方案"><a href="#react-运行时优化方案" class="header-anchor">#</a> React 运行时优化方案</h1> <h2 id="几大-js-框架的设计思路"><a href="#几大-js-框架的设计思路" class="header-anchor">#</a> 几大 JS 框架的设计思路</h2> <p><img src="/notes/assets/performance/react/ab64f152daea4ac7b135f65cb1ed180e_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>首先，是 <code>React</code>，<code>React</code> 是一个重运行时的框架，在数据发生变化后，并没有直接去操作 <code>dom</code>，而是生成一个新的所谓的虚拟 <code>dom</code>，它可以帮助我们解决跨平台和兼容性问题，并且通过 <code>diff</code> 算法得出最小的操作行为，这些全部都是在运行时来做的。</p> <p>最近很火的 <code>Svelte</code> ，就是一个典型的重编译的框架，作为开发者我们只需要去写模版和数据，经过 <code>Svelte</code> 的编译和预处理，代码基本全部会解析成原生的 <code>DOM</code> 操作，<code>Svelte</code> 的性能也是最接近原生 <code>js</code> 的。</p> <p><img src="/notes/assets/performance/react/981d005ce5c349ba873894cd7947e57b_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>那么，<code>Vue</code> 这个框架，在运行时和预编译取了一个很好地权衡，它保留了虚拟 <code>dom</code>，但是会通过响应式去控制虚拟 <code>dom</code> 的颗粒度，在预编译里面，又做了足够多的性能优化，做到了按需更新。</p> <h2 id="什么是编译时优化"><a href="#什么是编译时优化" class="header-anchor">#</a> 什么是编译时优化</h2> <p><code>Vue</code> 使用的是模版语法，模版 的特点，就是语法受限，我们可以使用 <code>v-if</code> <code>v-for</code> 这些指定的语法去编码，虽然这不够动态，但是由于语法是可枚举的，所以它可以在预编译层面做更多的预判，让 <code>Vue</code> 在运行时有更好的性能。下面我们可以看一个 <code>Vue 3.0</code> 具体在编译时所做的优化。</p> <p><img src="/notes/assets/performance/react/7097ad04c8c34b369780fa4d5a7d6980_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>传统 <code>vdom</code> 的 <code>Diff</code> 算法总归要按照 <code>vdom</code> 树的层级结构一层一层的遍历，所以 <code>diff</code> 性能会和模版的大小正相关，跟动态节点的数量无关。在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费。</p> <p><img src="/notes/assets/performance/react/ba0b551523ad4ac39bb814bd2b87f283_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>比如说，上面的这个代码示例，这几个静态的节点在组件更新阶段，是不可能发生变化的。如果能在 <code>diff</code> 阶段跳过静态内容，那我们就可以避免无用的 dom 树的遍历和比对。</p> <p><img src="/notes/assets/performance/react/c78481a690bf426bbaf3f5efad3423be_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>在 <code>Vue3.0</code> 里面，就有这样一条类似的优化策略，它的 <code>compiler</code> 可以根据节点的动态属性，为每个 虚拟 <code>dom</code> 创建不同的 <code>patchflag</code>，比如说，节点具有动态的 <code>text</code>，或者具有动态的 <code>class</code>，都会被打上不同的 <code>patchflag</code>。</p> <p><img src="/notes/assets/performance/react/7ce4f6ed6ec9494491698a13392531b8_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>然后 <code>patchflag</code> 再配合 <code>block tree</code>，就可以做到对不同节点的靶向更新。</p> <h2 id="死磕运行时"><a href="#死磕运行时" class="header-anchor">#</a> 死磕运行时</h2> <p><img src="/notes/assets/performance/react/4278c601cfad453eaf3afedd209b1cd5_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>我们再回来看 <code>React</code> ，它本身的思路是纯 <code>JS</code> 写法，这种方式非常灵活，但是，这也使它在编译时很难做太多的事情，像上面这样的编译时优化是很难实现的。所以，我们可以看到 <code>React</code> 几个大版本的的优化主要都在运行时。</p> <p>那么，运行时我们主要关注什么问题呢？</p> <p><img src="/notes/assets/performance/react/c71fb7966f8e43348cb8f79735063425_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>首先，就是 CPU 的问题，主流浏览器的刷新频率一般是 <code>60Hz</code>，也就是每秒刷新 <code>60</code> 次，大概 <code>16.6ms</code> 浏览器刷新一次。由于 <code>GUI</code> 渲染线程和 <code>JS</code> 线程是互斥的，所以 <code>JS</code> 脚本执行和浏览器布局、绘制不能同时执行。</p> <p>在这 <code>16.6ms</code> 的时间里，浏览器既需要完成 <code>JS</code> 的执行，也需要完成样式的重排和重绘，如果 <code>JS</code> 执行的时间过长，超出了 <code>16.6ms</code>，这次刷新就没有时间执行样式布局和样式绘制了，于是在页面上就会表现为卡顿。</p> <p><code>IO</code> 的问题就比较好理解了，很多组件需要等待一些网络延迟，那么怎么样才能在网络延迟存在的情况下，减少用户对网络延迟的感知呢？就是我们需要解决的问题。</p> <p>好，刚才我们聊完了为什么 <code>React</code> 主要的优化策略都在运行时，以及运行时主要解决的问题，下面我们就来具体看一下，<code>React</code> 最近的这几个大的版本都有什么更新和变化。</p> <h2 id="react-15-半自动批处理"><a href="#react-15-半自动批处理" class="header-anchor">#</a> React 15-半自动批处理</h2> <p>我们先来看看 <code>React 15</code> ，<code>React</code> 应该就是在这个版本之后开始火起来的，也是在这个版本之后，<code>React</code> 的更新也变得越来越慢。</p> <h3 id="架构"><a href="#架构" class="header-anchor">#</a> 架构</h3> <p>这一版的架构，还比较简单，主要就是分 <code>Reconciler</code> 和 <code>Renderer</code> 两个部分。</p> <p>![/notes/assets/performance/react/1d1558020ccf4de7a3505f32be45fddd_tplv-k3u1fbpfcp-watermark.awebp]</p> <ul><li><p><code>Reconciler</code>（协调器）—— 负责调用 <code>render</code> 生成虚拟 Dom 进行 Diff，找出变化后的虚拟 Dom</p></li> <li><p><code>Renderer</code>（渲染器）—— 负责接到 <code>Reconciler</code> 通知，将变化的组件渲染在当前宿主环境，比如浏览器，不同的宿主环境会有不同的 <code>Renderer</code>。</p></li></ul> <h3 id="批处理"><a href="#批处理" class="header-anchor">#</a> 批处理</h3> <p>下面我们来回顾一下，<code>React 15</code> 引入的一项优化：批处理，一道 <code>React</code> 的经典面试题：「setState 到底是同步的还是异步的」就是来源于此，我面试的时候也会经常问，具体的我在两年前的一篇文章中有介绍过：<code>由实际问题探究 setState 的执行机制</code> 。</p> <p>比如下面的代码，在一个生命周期里调用了四次 <code>setState</code>，其中最后两次在 <code>setTimeout</code> 的回调中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们来考虑一下两种情况：</p> <ul><li><p>假设 <code>React</code> 完全没有批处理机制，那么执行一个 <code>setState</code> 就会立即触发一次页面渲染，打印顺序应该是 <code>1、2、3、4</code></p></li> <li><p>假设 <code>React</code> 有一个完美的批处理机制，那么应该等整个函数执行完了之后再统一处理所有渲染，打印顺序应该是 <code>0、0、0、0</code></p></li></ul> <p>实际上，在这个版本上面代码的打印顺序是 <code>0、0、2、3</code>，从 <code>setTimeout</code> 回调里的打印结果我们就可以看出，<code>setState</code> 调用本身就是同步的，而外面之所以不能立即拿到结果就是因为 React 的批处理机制。</p> <p>正是因为 <code>setState</code> 是同步的，当同时触发多次 <code>setState</code> 时浏览器会一直被JS线程阻塞，那么那么浏览器就会掉帧，导致页面卡顿，所以 <code>React</code> 才引入了批处理的机制，主要是为了将同一上下文中触发的更新合并为一个更新。</p> <p>我们可以来看下源码中 <code>_processPendingState</code> 这个函数，这个函数是用来合并 <code>state</code> 暂存队列的，最后返回一个合并后的 <code>state</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token function-variable function">_processPendingState</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> inst <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_instance<span class="token punctuation">;</span>
  <span class="token keyword">var</span> queue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingStateQueue<span class="token punctuation">;</span>
  <span class="token keyword">var</span> replace <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingReplaceState<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingReplaceState <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> inst<span class="token punctuation">.</span>state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>replace <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> nextState <span class="token operator">=</span> <span class="token function">_assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> replace <span class="token operator">?</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> inst<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> replace <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> partial <span class="token operator">=</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">_assign</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> <span class="token keyword">typeof</span> partial <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">partial</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>inst<span class="token punctuation">,</span> nextState<span class="token punctuation">,</span> props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">:</span> partial<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> nextState<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>我们只需要关注下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">_assign</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> <span class="token keyword">typeof</span> partial <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">partial</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>inst<span class="token punctuation">,</span> nextState<span class="token punctuation">,</span> props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">:</span> partial<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果传入的是对象，很明显会被合并成一次：</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>
 nextState<span class="token punctuation">,</span>
 <span class="token punctuation">{</span>index<span class="token operator">:</span> state<span class="token punctuation">.</span>index<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span>index<span class="token operator">:</span> state<span class="token punctuation">.</span>index<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>如果传入的是函数，函数的参数 <code>preState</code> 是前一次合并后的结果，所以计算结果是准确的。</p> <p>如果在需要处理批处理的环境中（<code>React</code>生命周期、合成事件中）无论调用多少次 <code>setState</code>，都会不会执行更新，而是将要更新的 <code>state</code> 存入 <code>_pendingStateQueue</code>，将要更新的组件存入 <code>dirtyComponent</code>。当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 <code>didmount</code> 后会将 <code>isBranchUpdate</code> 设置为false。这时将执行之前累积的 <code>setState</code>。</p> <p><code>React</code> 内部会通过一个 <code>batchedUpdates</code> 函数去调用所有需要批处理的函数，执行逻辑大概如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">batchedUpdates</span><span class="token punctuation">(</span>onClick<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> batchedUpdates<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">A</span></span> <span class="token operator">=&gt;</span> <span class="token constant">R</span><span class="token punctuation">,</span> a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">R</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// ....</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为 <code>batchedUpdates</code> 本身是同步调用的，如果 fn 内部有异步执行，这时批处理早已执行完，所以这个版本的批处理无法处理异步函数，也被称作是半自动批处理。</p> <p>所以呢，<code>React</code> 给我们提供了 <code>unstable batchedUpdates</code> 这样的函数支持我们手动执行批处理。</p> <h3 id="react-15-的缺陷"><a href="#react-15-的缺陷" class="header-anchor">#</a> React 15 的缺陷</h3> <p><img src="/notes/assets/performance/react/c5593d41ca9c4ca4b5c5fb0dc24c0e33_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>虽然在 <code>React 15</code> 中引入批处理这样的优化逻辑，但是由于 <code>React 15</code> 本身的架构是递归同步更新的，如果节点非常多，即使只有一次 <code>state</code> 变更，<code>React</code> 也需要进行复杂的递归更新，更新一旦开始，中途就无法中断，直到遍历完整颗树，才能释放主线程。</p> <p><img src="/notes/assets/performance/react/780b09e9503346eaa39dad7146917879_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>我们可以参考图中的这个例子，当层级很深时，递归更新时间超过了 <code>16ms</code> ，如果这时有用户操作或动画渲染等，就会表现为卡顿。</p> <h2 id="react-16-让-concurrent-mode-成为可能"><a href="#react-16-让-concurrent-mode-成为可能" class="header-anchor">#</a> React 16 - 让 Concurrent Mode 成为可能</h2> <h3 id="架构-2"><a href="#架构-2" class="header-anchor">#</a> 架构</h3> <p>下面，我们再来看看 <code>React 16</code> 这个版本，相比 <code>React 15</code>，我们可以看到新的架构中多了一层 <code>Scheduler</code>，也就是调度器，然后在 <code>Reconciler</code> 这一层，使用 <code>Fiber</code> 架构进行了重构。具体的细节我们会在后面的章节进介绍。</p> <p><img src="/notes/assets/performance/react/a8434bf032094c1aaba7af6e8f2f24ed_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <ul><li><p><code>Scheduler</code>（调度器）—— 调度任务的优先级，高优任务优先进入 <code>Reconciler</code></p></li> <li><p><code>Reconciler</code>（协调器）—— 负责找出变化的组件（使用 <code>Fiber</code> 重构）</p></li> <li><p><code>Renderer</code>（渲染器）—— 负责将变化的组件渲染到页面上</p></li></ul> <p><code>React</code> ，也在后续的几个大版本中，都沿用了这个架构。</p> <p>除了架构上的变化，<code>React</code> 在这个版本提出了一个非常重要的概念，<code>Concurrent Mode</code>。</p> <h3 id="concurrent-mode"><a href="#concurrent-mode" class="header-anchor">#</a> Concurrent Mode</h3> <p><code>React</code> 官方的描述，是这样的：</p> <div class="custom-block tip"><p class="custom-block-title">Tips</p> <p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p></div> <p>为了让应用保持响应，我们需要先了解是什么在制约应用保持响应？</p> <p>里面比较重点的就是，让应用保持响应，我们可以先想一下到底是啥在限制应用保持响应呢？</p> <p>在 <code>CPU</code> 上，我们的主要问题是，在 JS 执行超过 <code>16.6 ms</code> 时，页面就会产生卡顿，那么 <code>React</code>  的解决思路，就是在浏览器每一帧的时间中预留一些时间给 JS 线程，<code>React</code> 利用这部分时间更新组件。当预留的时间不够用时，<code>React</code> 将线程控制权交还给浏览器让他有时间渲染UI，<code>React</code> 则等待下一帧再继续被中断的工作。</p> <p>其实，上面我们提到的，这种将长任务分拆到每一帧中，每一帧执行一小段任务的操作，就是我们常说的时间切片。</p> <p>那么在 IO 上面，需要解决的是发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应的问题。<code>React</code> 希望通过控制组件渲染的优先级去解决这个问题。</p> <p>实际上，<code>Concurrent Mode</code> 就是为了解决以上两个问题而设计的一套新的架构，重点就是，让组件的渲染 “可中断” 并且具有 “优先级”，其中包括几个不同的模块，他们各自负责不同的工作。 首先，我们先来看看，如何让组件的渲染 “可中断” 呢？</p> <h3 id="底层架构-fiber"><a href="#底层架构-fiber" class="header-anchor">#</a> 底层架构 - Fiber</h3> <p>在上面的章节我们讲到 <code>React15</code> 的 <code>Reconciler</code> 采用递归的方式执行，数据保存在递归调用栈中，这种递归的遍历方式肯定是无法中断的。</p> <p>所以，<code>React</code> 花费2年时间重构完成了Fiber架构，<code>React16</code> 的 <code>Reconciler</code> 基于 <code>Fiber</code> 节点实现。每个 <code>Fiber</code> 节点对应一个 <code>React elemen</code>t，注意一下，这里是对应，而不是等于。我们调用 <code>render</code> 函数产生的结果是 <code>React element</code>，而 <code>Fiber</code> 节点，由 <code>React Element</code> 创建而来。</p> <p><img src="/notes/assets/performance/react/d581d9b5a3f74050a600d24c528c3e3b_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>下面是一个 <code>Fiber</code> 节点的示例，除了包含 组件的类型，组件对应的 <code>DOM</code> 信息之外，<code>Fiber</code> 节点还保存了本次更新中该组件改变的状态、要执行的工作，需要被删除，被插入页面中，还是被更新。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>
  <span class="token parameter">tag<span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
  pendingProps<span class="token operator">:</span> mixed<span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  mode<span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 作为静态数据结构的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 用于连接其他Fiber节点形成Fiber树</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 动态工作单元的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调度优先级相关</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 指向该fiber在另一次更新时对应的fiber</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外，我们还可以看到当前节点与其他节点的链接关系，一个 <code>Fiber</code> 节点包括了他的 <code>child</code>（第一个子节点）、<code>sibling</code>（兄弟节点）、<code>return</code>（父节点）等属性。</p> <h4 id="双缓存"><a href="#双缓存" class="header-anchor">#</a> 双缓存</h4> <p><img src="/notes/assets/performance/react/97ccd97a30fa422fa7ffa1efc71326bd_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>在 <code>React</code> 中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树叫做 <code>current Fiber</code> 树，正在内存中构建的Fiber树叫做 <code>workInProgress Fiber</code>树，他们通过一个 <code>alternate</code> 属性连接。</p> <p>React应用的根节点会使用一个 <code>current</code> 指针指向当前的 <code>current Fiber</code> 树。
当 <code>workInProgress Fiber</code> 树构建完成交给 Renderer 渲染在页面上后，应用根节点的 <code>current</code> 指针就会 指向 <code>workInProgress Fiber</code> 树，此时 <code>workInProgress Fiber</code> 树就变为 <code>current Fiber</code> 树。</p> <p>由于 <code>React</code> 将渲染 DOM 树的机制改成了两个 <code>Fiber</code> 树交替工作的形式，所以可以在更新全部完成之后再切换指针指向，而在指针切换之前，我们随时可以放弃对另一颗树的修改。这，就让更新可中断成为了可能。</p> <p>在上面，我们提到了几个概念，<code>current Fiber</code>、<code>workInProgress Fiber</code>、jsx 对象 也就是 <code>React Element</code>、还有真正的 DOM 节点。</p> <p>那么，<code>Reconciler</code> 的工作就是使用 Diff 算法对比 <code>current Fiber</code> 和 <code>React Element</code> ，生成 <code>workInProgress Fiber</code> ，这个阶段是可中断的，<code>Renderer</code> 的工作是把 <code>workInProgress Fiber</code> 转换成真正的 DOM 节点。</p> <h3 id="调度器-scheduler"><a href="#调度器-scheduler" class="header-anchor">#</a> 调度器 - Scheduler</h3> <p>如果我们，还是用 <code>ReactDOM.render</code> 去同步运行 <code>Fiber</code> 架构，则 <code>Fiber</code> 架构与重构前并无区别。但是当我们配合上面提到的时间切片，就可以根据当前的宿主环境性能，为每个工作单元分配一个可运行时间，从而实现“异步可中断的更新”。</p> <p><img src="/notes/assets/performance/react/c736e1c6dde14fe1a8674988708f753e_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p><code>Scheduler</code> 就可以帮我们完成这件事情，我们可以看到，我们一次耗时很长的更新任务被拆分成一小段一小段的。这样浏览器就有剩余时间执行样式布局和样式绘制，减少掉帧的可能性。</p> <p><img src="/notes/assets/performance/react/a5b310f4723c457c9b91ed109cd5fc10_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>图中的动画效果，也变得非常丝滑。</p> <h4 id="requestidelcallback"><a href="#requestidelcallback" class="header-anchor">#</a> requestIdelCallback</h4> <p><img src="/notes/assets/performance/react/a8bad5b667a04119be0a9e3f5ccb4fd6_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>上面的图中，是浏览器一帧中做的一些事情，这里我们可以看到，当所有事情都做完了之后，会调用一个 <code>requestIdleCallback</code> 函数，在这个函数里我们可以拿到浏览器当前一祯的剩余时间。</p> <p>那这个 <code>API</code> 可以用来干啥呢？ 我们来看一个例子：</p> <p><img src="/notes/assets/performance/react/278b21324f784234a8443e830beacb0b_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>假如我们有左侧代码中这样非常长的耗时任务需要执行，不再经过其他额外处理的情况下，执行整个任务的执行时间肯定是超过 <code>16.6ms</code> 的。</p> <p>这里我们借助 <code>requestIdleCallback</code> 这个函数，可以将一个大任务分割成多个个小任务，在每一帧有空余时间情况下，逐步去执行小任务。</p> <p><img src="/notes/assets/performance/react/90fcd33e759845f8b3bd249fa3b1fc4c_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>借助这个 <code>API</code> ，我们就可以让浏览器仅在空闲时期的时候执行脚本。时间切片的本质，也就是模拟实现 <code>requestIdleCallback</code> 这个函数。</p> <div class="custom-block tip"><p class="custom-block-title">Tips</p> <p>由于兼容性和刷新帧率的问题，<code>React</code> 并没有直接使用 <code>requestIdleCallback</code> ， 而是使用了 <code>MessageChannel</code> 模拟实现，原理是一样的。</p></div> <h4 id="中断更新"><a href="#中断更新" class="header-anchor">#</a> 中断更新</h4> <p>在 <code>React</code> 的 <code>render</code> 阶段，开启 <code>Concurrent Mode</code> 时，每次遍历前，都会通过 <code>Scheduler</code> 提供的 <code>shouldYield</code> 方法判断是否需要中断遍历，使浏览器有时间渲染，参考下面的 <code>workLoopConcurrent</code> 函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>是否中断的判断依据，最重要的一点便是每个任务的剩余时间是否用完，<code>shouldYield()</code> 函数的作用就是检查时间是否到期。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// shouldYield(...) --&gt; Scheduler_shouldYield(...) --&gt; unstable_shouldYield(...)</span>
<span class="token comment">// --&gt; shouldYieldToHost(...)</span>
<span class="token comment">// --&gt; getCurrentTime() &gt;= deadline</span>
<span class="token comment">// --&gt;</span>
  <span class="token keyword">var</span> yieldInterval <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">var</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">performWorkUntilDeadline</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
      <span class="token keyword">var</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      deadline <span class="token operator">=</span> currentTime <span class="token operator">+</span> yieldInterval
      <span class="token operator">...</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，在 <code>Schdeduler</code> 中，那么每次到期，就会跳出工作循环，把线程的控制权交给浏览器，然后下次任务再继续当前的工作。这样，一个长的 <code>JS</code> 任务就会被切割成多个小段的任务。</p> <p>下面我们可以看下这段代码，<code>yieldInterval</code> 会根据当前设备的 <code>fps</code> 进行动态计算，这就响应了前面我们提到了 <code>Concurrent Mode</code> 这个概念的的定义，帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>fps <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  yieldInterval <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> fps<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// reset the framerate</span>
  yieldInterval <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Fiber</code> 架构配合 <code>Scheduler</code> 实现了 <code>Concurrent Mode</code> 的底层 — “异步可中断的更新”。</p> <h4 id="isinputpending"><a href="#isinputpending" class="header-anchor">#</a> isInputPending</h4> <p><img src="/notes/assets/performance/react/c9ed74922f9748f9abf87fa3b89780ab_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>那么，现在，其实我们不仅仅是在使用 <code>React</code> 的时候才能享受到这个优化策略。</p> <p>在 <code>Chrome 87</code> 版本，<code>React</code> 团队和 Chrome 团队合作，在浏览器上加入了一个新的 API <code>isInputPending</code>。这也是第一个将中断这个操作系统概念用于网页开发的API。</p> <p><img src="/notes/assets/performance/react/c90ff37baa134901a3bc0064e4037d87_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>即便不使用 <code>React</code>，我们也可以利用这个 <code>API</code>，来平衡 <code>JS</code> 执行、页面渲染及用户输入之间的优先级。</p> <p><img src="/notes/assets/performance/react/59f06fd3b48e408d8dffd27ad49634fb_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>我们可以看上面的代码示例，通过合理使用 <code>isInputPending</code> 方法，我们可以在页面渲染的时候及时响应用户输入，并且，当有长耗时的JS任务要执行时，可以通过 <code>isInputPending</code> 来中断JS的执行，将控制权交还给浏览器来执行用户响应。</p> <h3 id="优先级控制"><a href="#优先级控制" class="header-anchor">#</a> 优先级控制</h3> <p>如果一次更新在运行过程中被中断，然后重新开始一次新的更新，我们可以说：后一次更新打断了前一次更新。</p> <p>举一个简单的例子，我们现在正在吃饭，突然你女朋友给你打电话，你可能要先中断吃饭的操作，接完电话，再继续吃饭。</p> <p>也就是说，接电话这个操作的优先级，就要高于吃饭的优先级。React 根据人机交互的研究结果，为不同场景下产生的状态更新，赋予了不同的优先级，比如：</p> <ul><li><p>如果是生命周期方法：是最高优先级、同步执行的。</p></li> <li><p>受控的用户输入：比如输入框内输入文字，同步执行。</p></li> <li><p>一些交互事件：比如动画，高优先级执行。</p></li> <li><p>其他：比如数据请求，或者使用了 <code>suspense</code>、<code>transition</code> 这样的更新，是低优先级执行的。</p></li></ul> <p><img src="/notes/assets/performance/react/5bb1243eb8924d7bbc3bfd96f64adb96_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>比如，我们来看一下图中的这两次更新：首先，我们有一个改变当前主题的这样一个更新，这个更新呢，优先级比较低，而且比较耗时。那么，在主题改变这个状态更新的 <code>render</code> 阶段还没完成的时候，这时用户在 <code>Input</code> 框输入了一个新的字符。</p> <p>用户输入这个操作的优先级是比较高的，这时，我们就会先中断 主题更新 这个操作，优先响应用户输入，然后呢再基于上一次更新的结果，继续进行 主题更新的 <code>render</code> 和 commit 流程。
这，就是一次高优任务中断低优任务的操作。下面，我们再来看看 <code>React</code> 源码里，优先级是怎样实现的。</p> <h4 id="任务优先级"><a href="#任务优先级" class="header-anchor">#</a> 任务优先级</h4> <p>我们先来看看这段代码，里面声明了五种不同的优先级：</p> <ul><li><p><code>ImmediatePriority</code>: 代表立即执行的优先级，级别最高</p></li> <li><p><code>UserBlockingPriority</code>：代表用户阻塞级别的优先级</p></li> <li><p><code>NormalPriority</code>：这个就是最常见的正常的优先级</p></li> <li><p><code>LowPriority</code>：代表较低的优先级</p></li> <li><p><code>IdlePriority</code>：优先级最低，表示任务是可以闲置的</p></li></ul> <p><img src="/notes/assets/performance/react/85440c18537b495b867dd2d660dc168d_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>在 <code>React</code> 内部，只要是涉及到优先级调度的地方，都会使用 <code>runWithPriority</code> 这个函数，这个函数接受一个优先级还有一个回调函数，在这个回调函数的内部调用中，获取优先级的方法都会取到第一个参数传入的优先级。</p> <p>那么，这几种不同的优先级变量，怎么影响到具体的更新任务呢？</p> <p><img src="/notes/assets/performance/react/be143f7265984167b407fa8254357b07_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>我们可以看一下上面的代码，通过不同的优先级变量，我们会计算得出不同时长的过期时间 <code>expirationTime</code>。每个更新任务都会有一个 <code>expirationTime</code>， 任务的过期时间离当前时间越近，说明这个任务的优先级越高。</p> <p>那么，<code>expirationTime</code> ，是通过 <code>startTime</code> 也就是当前时间，加上一个 <code>timeout</code> 得出的。比如 <code>ImmediatePriority</code> 对应的 timeout 是 -1，那么这个任务的过期时间比当前时间还短，表示他已经过期了，需要立即被执行。</p> <p>那么，我们一整个 <code>React</code> 应用呢，在同一时间可能会产生不同的任务，我们的 <code>Scheduler</code> 呢，就会优先帮我们找到最高优先级的任务，去调度它的更新。那么，怎么才能最快的找到高优先级的任务呢？</p> <p><img src="/notes/assets/performance/react/2e324f27850241c29b0a7deb02014e02_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>实际上，<code>Scheduler</code> 将所有已经准备就绪，可以执行的任务，都存在了一个叫 <code>taskQueue</code> 的队列中，而这个队列使用了小顶堆这种数据结构。在小顶堆中，所有的任务按照任务的过期时间，从小到大进行排列，这样 <code>Scheduler</code> 就可以只花费O(1)复杂度找到队列中最早过期，或者说最高优先级的那个任务。</p> <h4 id="fiber优先级"><a href="#fiber优先级" class="header-anchor">#</a> Fiber优先级</h4> <p>那么，我们刚刚讲到的这个优先级的机制，实际上是 <code>React</code> 的 <code>Scheduler</code> 的优先级机制，在 <code>React</code> 内部，<code>Scheduler</code> 是一个独立包，它只负责任务的调度，甚至不关心这个任务具体是干什么，即使我们将 <code>Scheduler</code> 脱离 <code>React</code> 使用，也是可以的。</p> <p>所以 <code>Scheduler</code> 内部的优先级机制也是独立于 <code>React</code> 的， React 内部也有一套自己的优先级机制，因为我们需要知道在一棵 <code>Fiber</code> 树里，哪些 <code>Fiber</code> 以及 哪些 Update 对象，是高优先级的。</p> <p>在 <code>React16</code> 中，<code>Fiber</code> 和 <code>Update</code> 的优先级和 任务的优先级 是类似。<code>React</code> 会根据不同的操作优先级给每个 <code>Fiber</code> 节点的 <code>Update</code> 增加一个 <code>expirationTime</code> 。
但是由于某些问题，<code>React</code> 已经在 <code>Fiber</code> 中不再使用 <code>expirationTime</code> 去表示优先级，这个我们后面再讲。</p> <h3 id="生命周期的改变"><a href="#生命周期的改变" class="header-anchor">#</a> 生命周期的改变</h3> <p>在新的 <code>React</code> 架构中，一个组件的渲染被分为两个阶段：第一个阶段（也叫做 <code>render</code> 阶段）是可以被 <code>React</code> 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 <code>React</code> 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍。</p> <p>第二个阶段叫做 <code>commit</code> 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会直接做到这个组件的渲染结束。</p> <p><img src="/notes/assets/performance/react/3d1cf760ebe44eb2a17e85b08b82f7d2_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>两个阶段的分界点，就是 <code>render</code> 函数。<code>render</code> 函数之前的所有生命周期函数（包括 <code>render</code>)都属于第一阶段，之后的都属于第二阶段。开启 <code>Concurrent Mode</code> 之后， <code>render</code> 之前的所有生命周期都有可能会被打断，或者重复调用：</p> <ul><li><p><code>componentWillMount</code></p></li> <li><p><code>componentWillReceiveProps</code></p></li> <li><p><code>componentWillUpdate</code></p></li></ul> <p>如果我们在这些生命中期中引入了副作用，被重复执行，就可能会给我们的程序带来不可预知的问题，所以到了 <code>React v16.3</code>，<code>React</code> 干脆引入了一个新的生命周期函数 <code>getDerivedStateFromProps</code>，这个生命周期是一个 静态方法，在里面根本不能通过 <code>this</code> 访问到当前组件，输入只能通过参数，对组件渲染的影响只能通过返回值。</p> <p><img src="/notes/assets/performance/react/20082c3c52e3420289744a59bdfff7d0_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>所以，<code>getDerivedStateFromProps</code> 一定是一个纯函数，<code>React</code> 就是通过要求这种纯函数，强制开发者们必须适应 <code>Concurrent Mode</code> 。</p> <p>那，经过了上面的可中断、和优先级的实现， <code>React</code> 已经可以让程序在突破 CPU 的问题，实现保持响应了，那么 IO 的问题呢？</p> <h3 id="suspense"><a href="#suspense" class="header-anchor">#</a> Suspense</h3> <p><code>React 16.6</code> 新增了 <code>&lt;Suspense&gt;</code> 组件，它主要是解决运行时的 IO 问题。</p> <p><code>Suspense</code> 可以让组件 “等待” 某个异步操作，直到该异步操作结束再进行渲染。我们可以参考下面这段代码，我们通过 <code>Suspense</code> 实现了一个组件的懒加载。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> MonacoEditor <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'react-monaco-editor'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Editor Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MonacoEditor</span></span> 
     <span class="token attr-name">height</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">500</span><span class="token punctuation">}</span></span> 
     <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>json<span class="token punctuation">&quot;</span></span> 
     <span class="token attr-name">theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>vs<span class="token punctuation">&quot;</span></span> 
     <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>errorFileContext<span class="token punctuation">}</span></span> 
     <span class="token attr-name">options</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></span> 
  <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>那么为啥说 <code>Suspense</code> 可以解决 IO 的问题呢？我们自己通过其他的方式也可以实现这个懒加载。</p> <p>使用用 <code>Suspense</code> ，我们可以降低加载状的优先级，减少闪屏的问题。 比如数据很快返回的时候，我们可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。本质上讲 <code>Suspense</code> 内的组件子树比组件树的其他部分拥有更低的优先级
我们可以试想一下，如果没有 Suspense ，我们可能要去自己实现一个 <code>loading</code>，那么这个 <code>loading</code> 和其他组件渲染具有相同的优先级，这时无论 <code>IO</code> 有多快，我们的屏幕都会闪一下。</p> <p>那么如果在请求 <code>IO</code> 的这段时间里，我们利用这段时间加载了其他的组件，只要时间足够小，我们就不需要展示 <code>Lodaing</code>，这样就可以减少闪屏的问题。</p> <p>当然，<code>Suspense</code> 的作用不止于此，它更重要的还是优化了在 <code>React</code> 内部等待异步操作写法的问题，这个呢，在这里我们就不展开讲了。</p> <h3 id="react-16-的缺陷"><a href="#react-16-的缺陷" class="header-anchor">#</a> React 16 的缺陷</h3> <p>虽然 <code>React 16</code> 的核心工作全部都是在 <code>Concurrent Mode</code>  上，但是这并不代表 <code>Concurrent Mode</code>  已经可以稳定使用了，<code>React 16</code> 做的这些所有的工作只是让 <code>Concurrent Mode</code>  称为可能，并且在 <code>Concurrent Mode</code>  下做了一些小小的尝试，在 16 版本默认仍然是采用同步渲染的模式，为了后面的大范围开启 <code>Concurrent Mode</code> ，他还有很多努力要做。</p> <h2 id="react-17-稳定-concurrent-mode-的过渡版本"><a href="#react-17-稳定-concurrent-mode-的过渡版本" class="header-anchor">#</a> React 17 - 稳定 Concurrent Mode 的过渡版本</h2> <h3 id="没有新特性"><a href="#没有新特性" class="header-anchor">#</a> 没有新特性？</h3> <p>我们可以看到 <code>React17</code> 的更新日志里基本没有什么新特性，但是从官方仅有的一些描述中我们可以发现：<code>React17</code> 是一个用以稳定CM的过渡版本。</p> <p>由于 <code>Concurrent Mode</code> 带来的 <code>Breaking Change</code> 会使很多库都不兼容，我们不可能都在新项目里去用，所以 <code>React</code> 给我们提供了支持单项目多版本共存的支持，另外还有一个很重要的支持就是：使用 <code>Lanes</code> 重构了 <code>CM</code> 的优先级算法。</p> <h3 id="实现多版本共存"><a href="#实现多版本共存" class="header-anchor">#</a> 实现多版本共存</h3> <p>先简单说一下多版本共存。</p> <p><code>React</code> 采用的是 事件委托 的方式，它自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，主要是为了抹平了各个浏览器的兼容性问题。</p> <p>比如它并不会在你声明它们的时候就将它们 <code>attach</code> 到对应 <code>DOM</code> 节点上。 相反地，<code>React</code> 会直接在 <code>document</code> 节点上为每种事件类型 <code>attach</code> 一个处理器。这种方法不但在大型应用树上有性能优势，还会使添加新功能更容易。</p> <p>但是如果页面上有多个 <code>React</code> 版本，它们都会在 <code>document</code> 上注册事件。这会破坏 事件冒泡这些机制，外部的树仍然会接收到这个事件，这就使嵌套不同版本的 <code>React</code> 难以实现。</p> <p><img src="/notes/assets/performance/react/a304da8dd87649c6b8a33413c89e203a_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>这就是 <code>React</code> 要改变 <code>attach</code> 事件到 <code>DOM</code> 的底层实现方式的原因。</p> <p>在 <code>React 17</code> 中，<code>React</code> 会把事件 <code>attach</code> 到 <code>React</code> 渲染树的根 <code>DOM</code> 容器中，而不再 <code>attach</code> 到 <code>document</code> 级别 ：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> rootNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> rootNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这让多版本共存成为可能。</p> <h3 id="新的优先级算法-lanes"><a href="#新的优先级算法-lanes" class="header-anchor">#</a> 新的优先级算法 - lanes</h3> <p>上面的我们讲到，<code>Scheduler</code> 中的优先级和 React 中的优先级是不一致的，在 <code>React 16</code> <code>之前，React</code> 在 <code>Fiber</code> 中也使用 <code>expirationTime</code> 表示优先级，但是在 <code>React 17</code> 中，<code>React</code> 使用 <code>Lanes</code> 重构了 Fiber 的优先级算法。</p> <p>那么，以前的 <code>expirationTime</code> 有什么问题呢？在 <code>expirationTime</code> 最开始被设计的时候，React 体系中还没有 <code>Suspense</code> 异步渲染 的概念。假如现在有这样的场景: 有 3 个任务, 其优先级 A &gt; B &gt; C，正常来讲只需要按照优先级顺序执行就可以。</p> <p>但是现在有这样的情况：A 和 C 任务是 CPU 密集型，而 B 是IO密集型 （<code>Suspense</code> 会调用远程 api, 算是 IO 任务）， 即 <code>A(cpu) &gt; B(IO) &gt; C(cpu)</code>，在这种情况下呢，高优先级 <code>IO</code> 任务会中断低优先级 <code>CPU</code> 任务，这显然，是不合理的。</p> <p>那么使用 <code>expirationTime</code> ，它是以某一优先级作为整棵树的优先级更新标准，而并不是某一个具体的组件，这时我们的需求是需要把 任务B 从 一批任务 中分离出来，先处理 <code>cpu</code> 任务 A 和 C ，如果通过 <code>expirationTime</code> 实现呢，是比较困难的，它很难表示批的概念，也很难从一批任务里抽离单个任务，这时呢，我们就需要一种更细粒度的优先级。</p> <p><img src="/notes/assets/performance/react/34dd5cc5d42443ad9e7818420effc8b2_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>于是呢，<code>Lanes</code> 就出现了。以前使用 <code>expirationTime</code> 表示的字段，都改为了 <code>lane</code>。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>update<span class="token punctuation">.</span>expirationTime <span class="token operator">-</span><span class="token operator">&gt;</span> update<span class="token punctuation">.</span>lane
fiber<span class="token punctuation">.</span>expirationTime <span class="token operator">-</span><span class="token operator">&gt;</span> fiber<span class="token punctuation">.</span>lanes
</code></pre></div><p><code>Lane</code> 和 <code>Lanes</code> 就是单数和复数的关系, 代表单个任务的定义为 <code>Lane</code> ，代表多个任务的定义为 <code>Lanes</code> 。</p> <p><code>Lane</code> 的类型，被定义为二进制变量，这样，我们在做优先级计算的时候，用的都是位运算，在频繁更新的时候呢，占用内存少，计算速度也更快。</p> <p>React 一共定义了18 种 <code>Lane/Lanes</code> 变量 ，每一个变量占有 1 个或多个比特位，每一种 <code>Lane/Lanes</code> 都有对应的优先级。</p> <p>在代码中我们可以发现，越低优先级的 <code>lanes</code> 占用的位越多。比如 <code>InputDiscreteLanes</code>（也就是离散用交互的优先级）占了2个位，<code>TransitionLanes</code> 占了9个位。原因在于：越低优先级的更新越容易被打断（如果当前优先级的所有赛道都被占有了，则把当前优先级下降一个优先级），导致积压下来，所以需要更多的位。相反，最高优的同步更新的 <code>SyncLane</code> 不需要多余的 <code>lanes</code>。</p> <h2 id="react-18-更灵活-concurrent-renderring"><a href="#react-18-更灵活-concurrent-renderring" class="header-anchor">#</a> React 18 - 更灵活 Concurrent Renderring</h2> <p>就在前段时间， <code>React</code> 发布了 18 的 Alpha 版本，由于 <code>Concurrent Mode</code> 带来的巨大的 Break Change ，<code>React</code> 还不能默认开启它。所以，<code>React</code> 干脆换了个名字，叫 <code>Concurrent Rendering</code> 并发渲染机制。</p> <p>在 <code>React 17</code> 版本里，React 已经支持了多版本共存，所以 React 推荐大家渐进式升级，而不是一刀切。只有由这些 新特性触发的更新会启用并发渲染，所以大家不需要改动很多代码也可以直接使用 <code>React 18</code>，可以根据自己的节奏去尝试这些新特性。</p> <h3 id="createroot"><a href="#createroot" class="header-anchor">#</a> createRoot</h3> <p><code>React</code> 给我们提供了三种模式，之前我们一直使用的 <code>ReactDOM.render</code> 创建的应用属于 <code>legacy</code> ，在这个模式下更新还是同步的，一次 <code>render</code> 阶段对应一次 <code>commit</code> 阶段。</p> <p>如果使用 <code>ReactDOM.createRoot</code> 创建的应用，就默认开启了并发渲染，可以看到 在 <code>React 18</code> ，<code>createRoot</code> 这个函数已经不再是 <code>unstable</code>。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Create a root.</span>
<span class="token keyword">const</span> root <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">createRoot</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Render the top component to the root.</span>
root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>另外，还有个通过 <code>createBlockingRoot</code> 函数创建的 <code>blocking</code> 模式，这个函数是方便我们进行上面两种模式的过渡。</p> <p>在下面，我们也可以看到不同模式支持的特性对比。</p> <p><img src="/notes/assets/performance/react/86695189e31248a690d5bb1894c92437_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <h3 id="批处理的优化"><a href="#批处理的优化" class="header-anchor">#</a> 批处理的优化</h3> <p>上面我们提到了，在 <code>React 15</code> 中，<code>React</code> 实现了第一版的批处理机制。如果我们在一次事件回调中触发多次更新，他们会被合并为一次更新进行处理。</p> <p>主要的原因是 <code>batchedUpdates</code> 这个函数本身是同步调用的，如果 <code>fn</code> 内部有异步执行，这时批处理早已执行完，所以这个版本的批处理无法处理异步函数。</p> <p>但是，在 <code>React</code> 里我们有大量的状态更新要在异步回调里去做，那么在 <code>React 18</code> 呢，如果开启了异步渲染，就可以解决这个问题。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>val<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在 <code>Concurrent</code> 模式下，是以优先级为依据对更新进行合并的。</p> <p>我们可以看到，之前我们的这段代码最终的输出已经变成了 <code>0、0、1、1</code> ，为啥是这样的输出呢？下面我们简单看下基于优先级的批处理是怎么样的：</p> <p>在组件对应 <code>fiber</code> 挂载 <code>update</code> 后，就会进入「调度流程」。上面我们也讲到了 <code>Scheduler</code> 调度的作用就是，选出不同优先级的 <code>update</code> 中优先级最高的那个，以该优先级进入更新流程。进入调度后的流程大概如下：</p> <p><img src="/notes/assets/performance/react/8f7842f48340415b99cdf485eb0bbc1b_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>首先我们取出当前所有优先级中最高优先级的 <code>Lane</code>，然后根据 <code>Lane</code> 获取本次需要调度的优先级。</p> <p>然后我们需要获取在执行正式更新流程之前，是否之前存在一个调度，如果存在的话，和本次调度的优先级进行对比。</p> <p>如果是第一次执行 <code>setState</code> ，这个 <code>existingCallbackPriority</code> 肯定是不存在的，所以第一次出发会将 更新流程 <code>performConcurrentWorkOnRoot</code> 通过 <code>scheduleCallback</code> 进行调度。</p> <p>但是第二次 <code>setState</code> 进来，由于之前已经有了一次调度了，而且和本地的优先级是一致的，就会直接 <code>return</code>，不再调用 <code>scheduleCallback</code> 对 <code>performConcurrentWorkOnRoot</code> 进行调度。</p> <p>那么，一定时间过后，前面所有同一优先级的更新就会一起进入正式的更新流程。由于后面的 <code>setState</code> 是在 <code>setTimeout</code> 中调用的，<code>setTimeout</code> 具有较低的优先级，所有会放到下一个批次执行，所以，最终打印的结果是 <code>0、0、1、1</code>。</p> <p>以上，就是基于优先级的自动批处理的流程。有了这样的流程，我们就不需要之前 <code>React</code> 给我们提供的 <code>unstable_batchedUpdates</code> 这样手动批处理的函数了。</p> <h3 id="starttransition"><a href="#starttransition" class="header-anchor">#</a> startTransition</h3> <p>下面，我们来看看 <code>React 18</code> 新增的一个 API：<code>startTransition</code>：</p> <p>这个 <code>API</code> 可以让我们手动区分非紧急的状态更新，本质上还是对组件渲染优先级的控制。比如现在有这样一个场景：我们要去 <code>Input</code> 框输入一个值，然后下面需要同时给出通过我们输入后的值过滤出来的一些数据。</p> <p><img src="/notes/assets/performance/react/405b1e898a4645c5a17d3ec41f5f3d1b_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>因为你每次需要动态渲染出过滤后的值，所以你可能会将输入的值存储在一个 <code>state</code> 中，你的代码可能是下面这样的：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token function">setInputValue</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setSearchQuery</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>首先用户输入上去的值肯定是需要立刻渲染出来的，但是过滤出来的联想数据可能不需要那么快的渲染，如果我们不做任何额外的处理，在 <code>React 18</code> 之前，所有更新都会立刻被渲染，如果你的原始数据非常多，那么每次输入新的值后你需要进行的计算量（根据输入的值过滤出符合条件的数据）就非常大，所以每次用户输入后可能会有卡顿现象。</p> <p>所以，在以前我们可能会自己去加一些防抖这样的操作去人为的延迟过滤数据的计算和渲染。</p> <p>新的 <code>startTransition API</code> 可以让我们把数据标记成 <code>transitions</code> 状态。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> startTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>


<span class="token comment">// Urgent: Show what was typed</span>
<span class="token function">setInputValue</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Mark any state updates inside as transitions</span>
<span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Transition: Show the results</span>
  <span class="token function">setSearchQuery</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所有在 <code>startTransition</code> 回调中的更新都会被认为是 非紧急处理，如果出现更紧急的更新（比如用户又输入了新的值），则上面的更新都会被中断，直到没有其他紧急操作之后才会去继续执行更新。</p> <p>同时，<code>React</code> 还给我们提供了一个带有 <code>isPending</code> 过渡标志的 Hook：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span> 

<span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以使用它和一些 <code>loading</code> 动画结合使用：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token punctuation">{</span> isPending <span class="token operator">&amp;&amp;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Spinner</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">}</span>
</code></pre></div><p>下面，还有一个更典型的例子：</p> <p><img src="/notes/assets/performance/react/c60e80a17cac4e068fa9504232729564_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>拖动左边滑块会改变树渲染的节点数量。拖动顶部滑块会改变树的倾斜角度。最顶上有个帧雷达，可以实时显示更新过程中的掉帧情况。当不点击 <code>Use startTransition</code> 按钮，拖动顶上的滑块。可以看到：拖动并不流畅，顶上的帧雷达显示掉帧。</p> <p>这时，我们把 <code>tree</code> 的 <code>render</code> 放到 <code>startTransition</code> 中，虽然 <code>tree</code> 的更新还是很卡顿，但是雷达不会掉帧了。</p> <p><img src="/notes/assets/performance/react/2109bca777b446c79bb148efabe32355_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p><code>startTransition</code> 的实现其实也很简单，所有 在 <code>startTransition</code> 回调中执行的操作都会拿到一个 <code>isTransition</code> 标记，根据这个标记， React 会把更新赋予更低的优先级。</p> <h3 id="usedeferredvalue"><a href="#usedeferredvalue" class="header-anchor">#</a> useDeferredValue</h3> <p>除了手动标记某些操作的优先级，我们还能去标记某个具体状态的优先级。<code>React 18</code> 给我们提供了一个新的 <code>Hook useDeferredValue</code> 。</p> <p>比如我们现在有这样的场景，用户输入了一些信息后，我们需要对这些信息做一些处理然后渲染到下面的详情里，如果这个处理比较耗时，那么连续的用户输入会有卡顿的感觉。我们可以看图中这个例子，实际上所有的输入都是连续输入的。</p> <p>实际上，我们希望的是用户的输入能得到快速的响应，但是下面详情的渲染多等待一会其实无所谓。</p> <p><img src="/notes/assets/performance/react/b0f42b7cb9364f71a2addc878b589a03_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>这时，我们可以通过 <code>useDeferredValue</code> 创建一个 <code>deferredText</code>，真正的意思是 <code>deferredText</code> 的渲染被标记为了低优先级，它还有另一个参数，这个渲染的最大延迟时间。我们可以大概猜测到，<code>useDeferredValue</code> 的实现机制应该和 <code>expairedTime</code> 是类似的。</p> <p><img src="/notes/assets/performance/react/ddcf2eb122a44406a4eb669955275ad0_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>在图中我们可以看到 ，用户输入已经不会有卡顿的感觉了。</p> <p><img src="/notes/assets/performance/react/36910231dd864e5ab669ec2246532b3f_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <p>那么它跟我们手动实现的防抖有啥区别呢？</p> <p>防抖的主要问题是，不管我们的电脑渲染的有多快，它都会有一个固定的延迟，而 <code>useDeferredValue</code> 呢，只会在渲染比较耗时的情况下把优先级滞后，在多数情况下是不会有不必要的延迟的。</p> <h3 id="ssr-下的懒加载支持"><a href="#ssr-下的懒加载支持" class="header-anchor">#</a> SSR 下的懒加载支持</h3> <p>最后呢，就是 <code>Suspense</code> 了，在 React 18 以前， SSR 模式下是不支持使用 <code>Suspense</code> 组件的，而在 React 18 中，服务端渲染的组件也支持使用 <code>&lt;Suspense&gt;</code> 了：如果你把组件包裹在了<code>&lt;Suspense&gt;</code>中，服务端首先会把 <code>fallback</code> 中的组件作为 <code>HTML</code> 流式传输，一旦主组件加载完成，<code>React</code> 会发送新的 <code>HTML</code> 来替换整个组件。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Layout</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> 
&lt; Article /&gt; 
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Spinner</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Comments</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text"> 
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Layout</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>比如上面的代码，<code>&lt;Article&gt;</code> 组件首先会被渲染，<code>&lt;Comments&gt;</code> 组件将被 <code>fallback</code> 替换为 <code>&lt;Spinner&gt;</code> 。一旦 <code>&lt;Comments&gt;</code> 组件加载完成后，<code>React</code> 会才将其发送到浏览器，替换 <code>&lt;Spinner&gt;</code> 组件。</p></div> <!----> <div class="content__content-bottom"></div> <footer class="page-meta"><div class="edit-link"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon edit-icon"><path d="M117.953 696.992 64.306 959.696l265.931-49.336 450.204-452.505-212.284-213.376-450.204 452.513zm496.384-296.326L219.039 797.993l-46.108-46.34L568.233 354.33l46.104 46.335zm345.357-122.99-114.45 115.04-212.288-213.377 114.45-115.035 212.288 213.371zm0 0" fill="currentColor"></path></svg> <a href="https://github.com/sykinggg/notes/edit/main/docs/performance/react/reactBase.md" target="_blank" rel="noopener noreferrer">Edit this page</a></div> <div class="meta-item update-time"><span class="label">Last update:</span> <span class="info">November 8, 2021 08:59</span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/notes/performance/vue/vue2offsetTop/" class="prev"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon prev-icon"><path d="M906.783 588.79c-.02 8.499-6.882 15.36-15.38 15.37l-443.7-.01 75.704 191.682c2.52 6.42.482 13.763-5.038 17.91-5.52 4.168-13.138 4.147-18.616-.092L123.228 524.175a15.362 15.362 0 0 1-6-12.165c0-4.782 2.222-9.277 6-12.185L499.753 210.35a15.388 15.388 0 0 1 9.38-3.195c3.236 0 6.502 1.034 9.236 3.103 5.52 4.147 7.578 11.49 5.038 17.91L447.683 419.84l443.72-.01c8.498.01 15.36 6.881 15.36 15.36l.02 153.6z" fill="currentColor"></path></svg>
        Vue获取页面元素的相对位置
      </a></span> <span class="next"><a href="/notes/performance/react/reactTypescript/">
        React 中使用TypeScript
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 0 1-18.616.092 15.368 15.368 0 0 1-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 0 1 5.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 0 1 5.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <!----> <!----> <div class="content__page-bottom"></div></main> <!----></div><div class="global-ui"><!----><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">This app can be installed on your PC or mobile device.  This will allow this web app to look and behave like any other installed app.  You will find it in your app lists and be able to pin it to your home screen, start menus or task bars.  This installed web app will also be able to safely interact with other apps and your operating system. </p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>Description</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        Install <span></span></button> <button class="cancel-button">
        Cancel
      </button></div></div></div></div><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close"></button> <button class="pswp__button pswp__button--share"></button> <button class="pswp__button pswp__button--fs"></button> <button class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left"></button> <button class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><div class="my-popup" style="display:none;" data-v-5f98aac3><div class="my-popup-container" data-v-5f98aac3><div class="my-popup-exit" data-v-5f98aac3></div> <img src="" alt data-v-5f98aac3></div></div></div></div>
    <script src="/notes/assets/js/app.36180562.js" defer></script><script src="/notes/assets/js/vendors~layout-Layout.bad6b0ac.js" defer></script><script src="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.f2412bde.js" defer></script><script src="/notes/assets/js/page-React运行时优化方案.1815da7d.js" defer></script><script src="/notes/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound~layout-Slide.8a19680c.js" defer></script>
  </body>
</html>
